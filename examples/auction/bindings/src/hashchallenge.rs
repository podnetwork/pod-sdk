/**

Generated by the following Solidity interface...
```solidity
interface HashChallenge {
    event ChallengeClaimed(uint256 indexed challengeId, address indexed responder, uint256 rewardPaid, uint256 responseTime);
    event ChallengeCreated(uint256 indexed challengeId, address indexed challenger, address indexed responder, uint256 reward);
    event ChallengeRefunded(uint256 indexed challengeId, uint256 refundAmount);

    function calculateReward(uint256 elapsedTime, uint256 maxTime, uint256 totalReward) external pure returns (uint256);
    function challenges(uint256) external view returns (bytes32 hash, address challenger, address responder, uint256 reward, uint256 creationTime, uint256 maxDelay, uint256 rewardedAmount, uint256 refundedAmount, uint256 sequenceNumber);
    function claimChallenge(uint256 challengeId, bytes memory preimage, uint256 claimedDelay) external;
    function createChallenge(bytes32 dataHash, address responder, uint256 maxDelay, uint256 sequenceNumber) external payable;
    function getChallenge(uint256 challengeId) external view returns (bytes32 hash, address challenger, address responder, uint256 reward, uint256 creationTime, uint256 maxDelay, uint256 rewardedAmount, uint256 refundedAmount);
    function getRefund(uint256 challengeId, uint256 refundAmount) external;
    function previewReward(uint256 challengeId) external view returns (uint256);
}
```

...which was generated by the following JSON ABI:
```json
[
  {
    "type": "function",
    "name": "calculateReward",
    "inputs": [
      {
        "name": "elapsedTime",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "maxTime",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "totalReward",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "challenges",
    "inputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "hash",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "challenger",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "responder",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "reward",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "creationTime",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "maxDelay",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "rewardedAmount",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "refundedAmount",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "sequenceNumber",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "claimChallenge",
    "inputs": [
      {
        "name": "challengeId",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "preimage",
        "type": "bytes",
        "internalType": "bytes"
      },
      {
        "name": "claimedDelay",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "createChallenge",
    "inputs": [
      {
        "name": "dataHash",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "responder",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "maxDelay",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "sequenceNumber",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [],
    "stateMutability": "payable"
  },
  {
    "type": "function",
    "name": "getChallenge",
    "inputs": [
      {
        "name": "challengeId",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "hash",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "challenger",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "responder",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "reward",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "creationTime",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "maxDelay",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "rewardedAmount",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "refundedAmount",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getRefund",
    "inputs": [
      {
        "name": "challengeId",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "refundAmount",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "previewReward",
    "inputs": [
      {
        "name": "challengeId",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "event",
    "name": "ChallengeClaimed",
    "inputs": [
      {
        "name": "challengeId",
        "type": "uint256",
        "indexed": true,
        "internalType": "uint256"
      },
      {
        "name": "responder",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "rewardPaid",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      },
      {
        "name": "responseTime",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "ChallengeCreated",
    "inputs": [
      {
        "name": "challengeId",
        "type": "uint256",
        "indexed": true,
        "internalType": "uint256"
      },
      {
        "name": "challenger",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "responder",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "reward",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "ChallengeRefunded",
    "inputs": [
      {
        "name": "challengeId",
        "type": "uint256",
        "indexed": true,
        "internalType": "uint256"
      },
      {
        "name": "refundAmount",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      }
    ],
    "anonymous": false
  }
]
```*/
#[allow(
    non_camel_case_types,
    non_snake_case,
    clippy::pub_underscore_fields,
    clippy::style,
    clippy::empty_structs_with_brackets
)]
pub mod HashChallenge {
    use super::*;
    use alloy::sol_types as alloy_sol_types;
    /// The creation / init bytecode of the contract.
    ///
    /// ```text
    ///0x6080604052348015600e575f5ffd5b506119078061001c5f395ff3fe60806040526004361061006f575f3560e01c806385fa74bc1161004d57806385fa74bc146100fa5780638f1d377614610122578063a8e62b9714610166578063b973e1bf146101a25761006f565b806308e51b51146100735780631bdd4b741461008f5780632736d0b5146100d2575b5f5ffd5b61008d60048036038101906100889190610de5565b6101de565b005b34801561009a575f5ffd5b506100b560048036038101906100b09190610e49565b61049d565b6040516100c9989796959493929190610ea1565b60405180910390f35b3480156100dd575f5ffd5b506100f860048036038101906100f39190610f7e565b610539565b005b348015610105575f5ffd5b50610120600480360381019061011b9190610fef565b61084c565b005b34801561012d575f5ffd5b5061014860048036038101906101439190610e49565b610ad9565b60405161015d9998979695949392919061102d565b60405180910390f35b348015610171575f5ffd5b5061018c600480360381019061018791906110b8565b610b60565b6040516101999190611108565b60405180910390f35b3480156101ad575f5ffd5b506101c860048036038101906101c39190610e49565b610bca565b6040516101d59190611108565b60405180910390f35b5f3411610220576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016102179061117b565b60405180910390fd5b5f73ffffffffffffffffffffffffffffffffffffffff168373ffffffffffffffffffffffffffffffffffffffff160361028e576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610285906111e3565b60405180910390fd5b5f84848433856040516020016102a8959493929190611286565b604051602081830303815290604052805190602001205f1c90506040518061012001604052808681526020013373ffffffffffffffffffffffffffffffffffffffff1681526020018573ffffffffffffffffffffffffffffffffffffffff1681526020015f5f8481526020019081526020015f20600301543461032b9190611311565b81526020014281526020018481526020015f81526020015f8152602001838152505f5f8381526020019081526020015f205f820151815f01556020820151816001015f6101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055506040820151816002015f6101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff160217905550606082015181600301556080820151816004015560a0820151816005015560c0820151816006015560e0820151816007015561010082015181600801559050508373ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff16827fd2f7931a802085b3d0234d4c320ce7ee0041da96678ce2bf5c93e8d3d7e65f523460405161048e9190611108565b60405180910390a45050505050565b5f5f5f5f5f5f5f5f5f5f5f8b81526020019081526020015f209050805f0154816001015f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff16826002015f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff16836003015484600401548560050154866006015487600701549850985098509850985098509850985050919395975091939597565b5f5f5f8681526020019081526020015f2090505f816006015414610592576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016105899061138e565b60405180910390fd5b806002015f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff1614610623576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161061a9061141c565b60405180910390fd5b805f01548484604051610637929190611476565b60405180910390201461067f576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610676906114d8565b60405180910390fd5b5f8282600401546106909190611311565b90506106b4816040518060600160405280602281526020016118e560229139610c53565b5f6106c88484600501548560030154610b60565b90505f81101580156106de575082600301548111155b61071d576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161071490611540565b60405180910390fd5b8083600601819055505f836002015f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168260405161076e90611581565b5f6040518083038185875af1925050503d805f81146107a8576040519150601f19603f3d011682016040523d82523d5f602084013e6107ad565b606091505b50509050806107f1576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016107e8906115df565b60405180910390fd5b3373ffffffffffffffffffffffffffffffffffffffff16887f159b7bbdc606f37a40c138c8f053799889cf7524da20f9a31516f565659e349b848860405161083a9291906115fd565b60405180910390a35050505050505050565b5f5f8381526020019081526020015f206001015f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff16146108ec576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016108e39061166e565b60405180910390fd5b5f5f5f8481526020019081526020015f209050610951816005015482600401546109169190611311565b6040518060400160405280601e81526020017f43616e6e6f7420726566756e64206265666f7265206d61782064656c61790000815250610c63565b8060070154826109619190611311565b81600601548260030154610975919061168c565b10156109b6576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016109ad9061172f565b60405180910390fd5b5f816001015f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16836040516109fe90611581565b5f6040518083038185875af1925050503d805f8114610a38576040519150601f19603f3d011682016040523d82523d5f602084013e610a3d565b606091505b5050905080610a81576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610a7890611797565b60405180910390fd5b82826007015f828254610a949190611311565b92505081905550837f357c93e6bcb7005a62241e85838053bf0d968f2940a9bfd253d9e4b121a6bbe084604051610acb9190611108565b60405180910390a250505050565b5f602052805f5260405f205f91509050805f015490806001015f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1690806002015f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff16908060030154908060040154908060050154908060060154908060070154908060080154905089565b5f5f838510610b6f5783610b71565b845b90505f84670de0b6b3a76400008387610b8a919061168c565b610b9491906117b5565b610b9e9190611823565b9050670de0b6b3a76400008185610bb591906117b5565b610bbf9190611823565b925050509392505050565b5f5f5f5f8481526020019081526020015f2090505f816006015414610c24576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610c1b9061138e565b60405180910390fd5b5f816004015442610c35919061168c565b9050610c4a8183600501548460030154610b60565b92505050919050565b610c5f82421082610c73565b5050565b610c6f82421182610c73565b5050565b7f3dcdf63b41c103567d7225976ad9145e866c7a7dccc6c277ea86abbd268fbac95f1c73ffffffffffffffffffffffffffffffffffffffff1682604051602001610cbd919061186d565b604051602081830303815290604052604051610cd991906118ce565b5f60405180830381855afa9150503d805f8114610d11576040519150601f19603f3d011682016040523d82523d5f602084013e610d16565b606091505b5050505050565b5f5ffd5b5f5ffd5b5f819050919050565b610d3781610d25565b8114610d41575f5ffd5b50565b5f81359050610d5281610d2e565b92915050565b5f73ffffffffffffffffffffffffffffffffffffffff82169050919050565b5f610d8182610d58565b9050919050565b610d9181610d77565b8114610d9b575f5ffd5b50565b5f81359050610dac81610d88565b92915050565b5f819050919050565b610dc481610db2565b8114610dce575f5ffd5b50565b5f81359050610ddf81610dbb565b92915050565b5f5f5f5f60808587031215610dfd57610dfc610d1d565b5b5f610e0a87828801610d44565b9450506020610e1b87828801610d9e565b9350506040610e2c87828801610dd1565b9250506060610e3d87828801610dd1565b91505092959194509250565b5f60208284031215610e5e57610e5d610d1d565b5b5f610e6b84828501610dd1565b91505092915050565b610e7d81610d25565b82525050565b610e8c81610d77565b82525050565b610e9b81610db2565b82525050565b5f61010082019050610eb55f83018b610e74565b610ec2602083018a610e83565b610ecf6040830189610e83565b610edc6060830188610e92565b610ee96080830187610e92565b610ef660a0830186610e92565b610f0360c0830185610e92565b610f1060e0830184610e92565b9998505050505050505050565b5f5ffd5b5f5ffd5b5f5ffd5b5f5f83601f840112610f3e57610f3d610f1d565b5b8235905067ffffffffffffffff811115610f5b57610f5a610f21565b5b602083019150836001820283011115610f7757610f76610f25565b5b9250929050565b5f5f5f5f60608587031215610f9657610f95610d1d565b5b5f610fa387828801610dd1565b945050602085013567ffffffffffffffff811115610fc457610fc3610d21565b5b610fd087828801610f29565b93509350506040610fe387828801610dd1565b91505092959194509250565b5f5f6040838503121561100557611004610d1d565b5b5f61101285828601610dd1565b925050602061102385828601610dd1565b9150509250929050565b5f610120820190506110415f83018c610e74565b61104e602083018b610e83565b61105b604083018a610e83565b6110686060830189610e92565b6110756080830188610e92565b61108260a0830187610e92565b61108f60c0830186610e92565b61109c60e0830185610e92565b6110aa610100830184610e92565b9a9950505050505050505050565b5f5f5f606084860312156110cf576110ce610d1d565b5b5f6110dc86828701610dd1565b93505060206110ed86828701610dd1565b92505060406110fe86828701610dd1565b9150509250925092565b5f60208201905061111b5f830184610e92565b92915050565b5f82825260208201905092915050565b7f526577617264206d7573742062652067726561746572207468616e20300000005f82015250565b5f611165601d83611121565b915061117082611131565b602082019050919050565b5f6020820190508181035f83015261119281611159565b9050919050565b7f526573706f6e6465722063616e6e6f74206265207a65726f20616464726573735f82015250565b5f6111cd602083611121565b91506111d882611199565b602082019050919050565b5f6020820190508181035f8301526111fa816111c1565b9050919050565b5f819050919050565b61121b61121682610d25565b611201565b82525050565b5f8160601b9050919050565b5f61123782611221565b9050919050565b5f6112488261122d565b9050919050565b61126061125b82610d77565b61123e565b82525050565b5f819050919050565b61128061127b82610db2565b611266565b82525050565b5f611291828861120a565b6020820191506112a1828761124f565b6014820191506112b1828661126f565b6020820191506112c1828561124f565b6014820191506112d1828461126f565b6020820191508190509695505050505050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52601160045260245ffd5b5f61131b82610db2565b915061132683610db2565b925082820190508082111561133e5761133d6112e4565b5b92915050565b7f4368616c6c656e676520616c726561647920636c61696d6564000000000000005f82015250565b5f611378601983611121565b915061138382611344565b602082019050919050565b5f6020820190508181035f8301526113a58161136c565b9050919050565b7f4f6e6c7920696e74656e64656420726573706f6e6465722063616e20636c61695f8201527f6d00000000000000000000000000000000000000000000000000000000000000602082015250565b5f611406602183611121565b9150611411826113ac565b604082019050919050565b5f6020820190508181035f830152611433816113fa565b9050919050565b5f81905092915050565b828183375f83830152505050565b5f61145d838561143a565b935061146a838584611444565b82840190509392505050565b5f611482828486611452565b91508190509392505050565b7f496e636f727265637420707265696d61676500000000000000000000000000005f82015250565b5f6114c2601283611121565b91506114cd8261148e565b602082019050919050565b5f6020820190508181035f8301526114ef816114b6565b9050919050565b7f496e76616c69642072657761726420616d6f756e7400000000000000000000005f82015250565b5f61152a601583611121565b9150611535826114f6565b602082019050919050565b5f6020820190508181035f8301526115578161151e565b9050919050565b50565b5f61156c5f8361143a565b91506115778261155e565b5f82019050919050565b5f61158b82611561565b9150819050919050565b7f5472616e73666572206661696c656400000000000000000000000000000000005f82015250565b5f6115c9600f83611121565b91506115d482611595565b602082019050919050565b5f6020820190508181035f8301526115f6816115bd565b9050919050565b5f6040820190506116105f830185610e92565b61161d6020830184610e92565b9392505050565b7f4f6e6c79206368616c6c656e6765722063616e20726566756e640000000000005f82015250565b5f611658601a83611121565b915061166382611624565b602082019050919050565b5f6020820190508181035f8301526116858161164c565b9050919050565b5f61169682610db2565b91506116a183610db2565b92508282039050818111156116b9576116b86112e4565b5b92915050565b7f43616e6e6f7420726566756e64206d6f7265207468616e2074686520616d6f755f8201527f6e742072656d61696e696e6720616674657220636c61696d696e670000000000602082015250565b5f611719603b83611121565b9150611724826116bf565b604082019050919050565b5f6020820190508181035f8301526117468161170d565b9050919050565b7f526566756e64206661696c6564000000000000000000000000000000000000005f82015250565b5f611781600d83611121565b915061178c8261174d565b602082019050919050565b5f6020820190508181035f8301526117ae81611775565b9050919050565b5f6117bf82610db2565b91506117ca83610db2565b92508282026117d881610db2565b915082820484148315176117ef576117ee6112e4565b5b5092915050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52601260045260245ffd5b5f61182d82610db2565b915061183883610db2565b925082611848576118476117f6565b5b828204905092915050565b5f8115159050919050565b61186781611853565b82525050565b5f6020820190506118805f83018461185e565b92915050565b5f81519050919050565b8281835e5f83830152505050565b5f6118a882611886565b6118b2818561143a565b93506118c2818560208601611890565b80840191505092915050565b5f6118d9828461189e565b91508190509291505056fe4d6f7265207468616e20636c61696d65642064656c61792068617320706173736564
    /// ```
    #[rustfmt::skip]
    #[allow(clippy::all)]
    pub static BYTECODE: alloy_sol_types::private::Bytes = alloy_sol_types::private::Bytes::from_static(
        b"`\x80`@R4\x80\x15`\x0EW__\xFD[Pa\x19\x07\x80a\0\x1C_9_\xF3\xFE`\x80`@R`\x046\x10a\0oW_5`\xE0\x1C\x80c\x85\xFAt\xBC\x11a\0MW\x80c\x85\xFAt\xBC\x14a\0\xFAW\x80c\x8F\x1D7v\x14a\x01\"W\x80c\xA8\xE6+\x97\x14a\x01fW\x80c\xB9s\xE1\xBF\x14a\x01\xA2Wa\0oV[\x80c\x08\xE5\x1BQ\x14a\0sW\x80c\x1B\xDDKt\x14a\0\x8FW\x80c'6\xD0\xB5\x14a\0\xD2W[__\xFD[a\0\x8D`\x04\x806\x03\x81\x01\x90a\0\x88\x91\x90a\r\xE5V[a\x01\xDEV[\0[4\x80\x15a\0\x9AW__\xFD[Pa\0\xB5`\x04\x806\x03\x81\x01\x90a\0\xB0\x91\x90a\x0EIV[a\x04\x9DV[`@Qa\0\xC9\x98\x97\x96\x95\x94\x93\x92\x91\x90a\x0E\xA1V[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\0\xDDW__\xFD[Pa\0\xF8`\x04\x806\x03\x81\x01\x90a\0\xF3\x91\x90a\x0F~V[a\x059V[\0[4\x80\x15a\x01\x05W__\xFD[Pa\x01 `\x04\x806\x03\x81\x01\x90a\x01\x1B\x91\x90a\x0F\xEFV[a\x08LV[\0[4\x80\x15a\x01-W__\xFD[Pa\x01H`\x04\x806\x03\x81\x01\x90a\x01C\x91\x90a\x0EIV[a\n\xD9V[`@Qa\x01]\x99\x98\x97\x96\x95\x94\x93\x92\x91\x90a\x10-V[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x01qW__\xFD[Pa\x01\x8C`\x04\x806\x03\x81\x01\x90a\x01\x87\x91\x90a\x10\xB8V[a\x0B`V[`@Qa\x01\x99\x91\x90a\x11\x08V[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x01\xADW__\xFD[Pa\x01\xC8`\x04\x806\x03\x81\x01\x90a\x01\xC3\x91\x90a\x0EIV[a\x0B\xCAV[`@Qa\x01\xD5\x91\x90a\x11\x08V[`@Q\x80\x91\x03\x90\xF3[_4\x11a\x02 W`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x02\x17\x90a\x11{V[`@Q\x80\x91\x03\x90\xFD[_s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x83s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x03a\x02\x8EW`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x02\x85\x90a\x11\xE3V[`@Q\x80\x91\x03\x90\xFD[_\x84\x84\x843\x85`@Q` \x01a\x02\xA8\x95\x94\x93\x92\x91\x90a\x12\x86V[`@Q` \x81\x83\x03\x03\x81R\x90`@R\x80Q\x90` \x01 _\x1C\x90P`@Q\x80a\x01 \x01`@R\x80\x86\x81R` \x013s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x85s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01__\x84\x81R` \x01\x90\x81R` \x01_ `\x03\x01T4a\x03+\x91\x90a\x13\x11V[\x81R` \x01B\x81R` \x01\x84\x81R` \x01_\x81R` \x01_\x81R` \x01\x83\x81RP__\x83\x81R` \x01\x90\x81R` \x01_ _\x82\x01Q\x81_\x01U` \x82\x01Q\x81`\x01\x01_a\x01\0\n\x81T\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x02\x17\x90UP`@\x82\x01Q\x81`\x02\x01_a\x01\0\n\x81T\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x02\x17\x90UP``\x82\x01Q\x81`\x03\x01U`\x80\x82\x01Q\x81`\x04\x01U`\xA0\x82\x01Q\x81`\x05\x01U`\xC0\x82\x01Q\x81`\x06\x01U`\xE0\x82\x01Q\x81`\x07\x01Ua\x01\0\x82\x01Q\x81`\x08\x01U\x90PP\x83s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x163s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x82\x7F\xD2\xF7\x93\x1A\x80 \x85\xB3\xD0#ML2\x0C\xE7\xEE\0A\xDA\x96g\x8C\xE2\xBF\\\x93\xE8\xD3\xD7\xE6_R4`@Qa\x04\x8E\x91\x90a\x11\x08V[`@Q\x80\x91\x03\x90\xA4PPPPPV[___________\x8B\x81R` \x01\x90\x81R` \x01_ \x90P\x80_\x01T\x81`\x01\x01_\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x82`\x02\x01_\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x83`\x03\x01T\x84`\x04\x01T\x85`\x05\x01T\x86`\x06\x01T\x87`\x07\x01T\x98P\x98P\x98P\x98P\x98P\x98P\x98P\x98PP\x91\x93\x95\x97P\x91\x93\x95\x97V[___\x86\x81R` \x01\x90\x81R` \x01_ \x90P_\x81`\x06\x01T\x14a\x05\x92W`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x05\x89\x90a\x13\x8EV[`@Q\x80\x91\x03\x90\xFD[\x80`\x02\x01_\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x163s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14a\x06#W`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x06\x1A\x90a\x14\x1CV[`@Q\x80\x91\x03\x90\xFD[\x80_\x01T\x84\x84`@Qa\x067\x92\x91\x90a\x14vV[`@Q\x80\x91\x03\x90 \x14a\x06\x7FW`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x06v\x90a\x14\xD8V[`@Q\x80\x91\x03\x90\xFD[_\x82\x82`\x04\x01Ta\x06\x90\x91\x90a\x13\x11V[\x90Pa\x06\xB4\x81`@Q\x80``\x01`@R\x80`\"\x81R` \x01a\x18\xE5`\"\x919a\x0CSV[_a\x06\xC8\x84\x84`\x05\x01T\x85`\x03\x01Ta\x0B`V[\x90P_\x81\x10\x15\x80\x15a\x06\xDEWP\x82`\x03\x01T\x81\x11\x15[a\x07\x1DW`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x07\x14\x90a\x15@V[`@Q\x80\x91\x03\x90\xFD[\x80\x83`\x06\x01\x81\x90UP_\x83`\x02\x01_\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x82`@Qa\x07n\x90a\x15\x81V[_`@Q\x80\x83\x03\x81\x85\x87Z\xF1\x92PPP=\x80_\x81\x14a\x07\xA8W`@Q\x91P`\x1F\x19`?=\x01\x16\x82\x01`@R=\x82R=_` \x84\x01>a\x07\xADV[``\x91P[PP\x90P\x80a\x07\xF1W`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x07\xE8\x90a\x15\xDFV[`@Q\x80\x91\x03\x90\xFD[3s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x88\x7F\x15\x9B{\xBD\xC6\x06\xF3z@\xC18\xC8\xF0Sy\x98\x89\xCFu$\xDA \xF9\xA3\x15\x16\xF5ee\x9E4\x9B\x84\x88`@Qa\x08:\x92\x91\x90a\x15\xFDV[`@Q\x80\x91\x03\x90\xA3PPPPPPPPV[__\x83\x81R` \x01\x90\x81R` \x01_ `\x01\x01_\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x163s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14a\x08\xECW`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x08\xE3\x90a\x16nV[`@Q\x80\x91\x03\x90\xFD[___\x84\x81R` \x01\x90\x81R` \x01_ \x90Pa\tQ\x81`\x05\x01T\x82`\x04\x01Ta\t\x16\x91\x90a\x13\x11V[`@Q\x80`@\x01`@R\x80`\x1E\x81R` \x01\x7FCannot refund before max delay\0\0\x81RPa\x0CcV[\x80`\x07\x01T\x82a\ta\x91\x90a\x13\x11V[\x81`\x06\x01T\x82`\x03\x01Ta\tu\x91\x90a\x16\x8CV[\x10\x15a\t\xB6W`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\t\xAD\x90a\x17/V[`@Q\x80\x91\x03\x90\xFD[_\x81`\x01\x01_\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x83`@Qa\t\xFE\x90a\x15\x81V[_`@Q\x80\x83\x03\x81\x85\x87Z\xF1\x92PPP=\x80_\x81\x14a\n8W`@Q\x91P`\x1F\x19`?=\x01\x16\x82\x01`@R=\x82R=_` \x84\x01>a\n=V[``\x91P[PP\x90P\x80a\n\x81W`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\nx\x90a\x17\x97V[`@Q\x80\x91\x03\x90\xFD[\x82\x82`\x07\x01_\x82\x82Ta\n\x94\x91\x90a\x13\x11V[\x92PP\x81\x90UP\x83\x7F5|\x93\xE6\xBC\xB7\0Zb$\x1E\x85\x83\x80S\xBF\r\x96\x8F)@\xA9\xBF\xD2S\xD9\xE4\xB1!\xA6\xBB\xE0\x84`@Qa\n\xCB\x91\x90a\x11\x08V[`@Q\x80\x91\x03\x90\xA2PPPPV[_` R\x80_R`@_ _\x91P\x90P\x80_\x01T\x90\x80`\x01\x01_\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90\x80`\x02\x01_\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90\x80`\x03\x01T\x90\x80`\x04\x01T\x90\x80`\x05\x01T\x90\x80`\x06\x01T\x90\x80`\x07\x01T\x90\x80`\x08\x01T\x90P\x89V[__\x83\x85\x10a\x0BoW\x83a\x0BqV[\x84[\x90P_\x84g\r\xE0\xB6\xB3\xA7d\0\0\x83\x87a\x0B\x8A\x91\x90a\x16\x8CV[a\x0B\x94\x91\x90a\x17\xB5V[a\x0B\x9E\x91\x90a\x18#V[\x90Pg\r\xE0\xB6\xB3\xA7d\0\0\x81\x85a\x0B\xB5\x91\x90a\x17\xB5V[a\x0B\xBF\x91\x90a\x18#V[\x92PPP\x93\x92PPPV[____\x84\x81R` \x01\x90\x81R` \x01_ \x90P_\x81`\x06\x01T\x14a\x0C$W`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x0C\x1B\x90a\x13\x8EV[`@Q\x80\x91\x03\x90\xFD[_\x81`\x04\x01TBa\x0C5\x91\x90a\x16\x8CV[\x90Pa\x0CJ\x81\x83`\x05\x01T\x84`\x03\x01Ta\x0B`V[\x92PPP\x91\x90PV[a\x0C_\x82B\x10\x82a\x0CsV[PPV[a\x0Co\x82B\x11\x82a\x0CsV[PPV[\x7F=\xCD\xF6;A\xC1\x03V}r%\x97j\xD9\x14^\x86lz}\xCC\xC6\xC2w\xEA\x86\xAB\xBD&\x8F\xBA\xC9_\x1Cs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x82`@Q` \x01a\x0C\xBD\x91\x90a\x18mV[`@Q` \x81\x83\x03\x03\x81R\x90`@R`@Qa\x0C\xD9\x91\x90a\x18\xCEV[_`@Q\x80\x83\x03\x81\x85Z\xFA\x91PP=\x80_\x81\x14a\r\x11W`@Q\x91P`\x1F\x19`?=\x01\x16\x82\x01`@R=\x82R=_` \x84\x01>a\r\x16V[``\x91P[PPPPPV[__\xFD[__\xFD[_\x81\x90P\x91\x90PV[a\r7\x81a\r%V[\x81\x14a\rAW__\xFD[PV[_\x815\x90Pa\rR\x81a\r.V[\x92\x91PPV[_s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x16\x90P\x91\x90PV[_a\r\x81\x82a\rXV[\x90P\x91\x90PV[a\r\x91\x81a\rwV[\x81\x14a\r\x9BW__\xFD[PV[_\x815\x90Pa\r\xAC\x81a\r\x88V[\x92\x91PPV[_\x81\x90P\x91\x90PV[a\r\xC4\x81a\r\xB2V[\x81\x14a\r\xCEW__\xFD[PV[_\x815\x90Pa\r\xDF\x81a\r\xBBV[\x92\x91PPV[____`\x80\x85\x87\x03\x12\x15a\r\xFDWa\r\xFCa\r\x1DV[[_a\x0E\n\x87\x82\x88\x01a\rDV[\x94PP` a\x0E\x1B\x87\x82\x88\x01a\r\x9EV[\x93PP`@a\x0E,\x87\x82\x88\x01a\r\xD1V[\x92PP``a\x0E=\x87\x82\x88\x01a\r\xD1V[\x91PP\x92\x95\x91\x94P\x92PV[_` \x82\x84\x03\x12\x15a\x0E^Wa\x0E]a\r\x1DV[[_a\x0Ek\x84\x82\x85\x01a\r\xD1V[\x91PP\x92\x91PPV[a\x0E}\x81a\r%V[\x82RPPV[a\x0E\x8C\x81a\rwV[\x82RPPV[a\x0E\x9B\x81a\r\xB2V[\x82RPPV[_a\x01\0\x82\x01\x90Pa\x0E\xB5_\x83\x01\x8Ba\x0EtV[a\x0E\xC2` \x83\x01\x8Aa\x0E\x83V[a\x0E\xCF`@\x83\x01\x89a\x0E\x83V[a\x0E\xDC``\x83\x01\x88a\x0E\x92V[a\x0E\xE9`\x80\x83\x01\x87a\x0E\x92V[a\x0E\xF6`\xA0\x83\x01\x86a\x0E\x92V[a\x0F\x03`\xC0\x83\x01\x85a\x0E\x92V[a\x0F\x10`\xE0\x83\x01\x84a\x0E\x92V[\x99\x98PPPPPPPPPV[__\xFD[__\xFD[__\xFD[__\x83`\x1F\x84\x01\x12a\x0F>Wa\x0F=a\x0F\x1DV[[\x825\x90Pg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\x0F[Wa\x0FZa\x0F!V[[` \x83\x01\x91P\x83`\x01\x82\x02\x83\x01\x11\x15a\x0FwWa\x0Fva\x0F%V[[\x92P\x92\x90PV[____``\x85\x87\x03\x12\x15a\x0F\x96Wa\x0F\x95a\r\x1DV[[_a\x0F\xA3\x87\x82\x88\x01a\r\xD1V[\x94PP` \x85\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\x0F\xC4Wa\x0F\xC3a\r!V[[a\x0F\xD0\x87\x82\x88\x01a\x0F)V[\x93P\x93PP`@a\x0F\xE3\x87\x82\x88\x01a\r\xD1V[\x91PP\x92\x95\x91\x94P\x92PV[__`@\x83\x85\x03\x12\x15a\x10\x05Wa\x10\x04a\r\x1DV[[_a\x10\x12\x85\x82\x86\x01a\r\xD1V[\x92PP` a\x10#\x85\x82\x86\x01a\r\xD1V[\x91PP\x92P\x92\x90PV[_a\x01 \x82\x01\x90Pa\x10A_\x83\x01\x8Ca\x0EtV[a\x10N` \x83\x01\x8Ba\x0E\x83V[a\x10[`@\x83\x01\x8Aa\x0E\x83V[a\x10h``\x83\x01\x89a\x0E\x92V[a\x10u`\x80\x83\x01\x88a\x0E\x92V[a\x10\x82`\xA0\x83\x01\x87a\x0E\x92V[a\x10\x8F`\xC0\x83\x01\x86a\x0E\x92V[a\x10\x9C`\xE0\x83\x01\x85a\x0E\x92V[a\x10\xAAa\x01\0\x83\x01\x84a\x0E\x92V[\x9A\x99PPPPPPPPPPV[___``\x84\x86\x03\x12\x15a\x10\xCFWa\x10\xCEa\r\x1DV[[_a\x10\xDC\x86\x82\x87\x01a\r\xD1V[\x93PP` a\x10\xED\x86\x82\x87\x01a\r\xD1V[\x92PP`@a\x10\xFE\x86\x82\x87\x01a\r\xD1V[\x91PP\x92P\x92P\x92V[_` \x82\x01\x90Pa\x11\x1B_\x83\x01\x84a\x0E\x92V[\x92\x91PPV[_\x82\x82R` \x82\x01\x90P\x92\x91PPV[\x7FReward must be greater than 0\0\0\0_\x82\x01RPV[_a\x11e`\x1D\x83a\x11!V[\x91Pa\x11p\x82a\x111V[` \x82\x01\x90P\x91\x90PV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01Ra\x11\x92\x81a\x11YV[\x90P\x91\x90PV[\x7FResponder cannot be zero address_\x82\x01RPV[_a\x11\xCD` \x83a\x11!V[\x91Pa\x11\xD8\x82a\x11\x99V[` \x82\x01\x90P\x91\x90PV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01Ra\x11\xFA\x81a\x11\xC1V[\x90P\x91\x90PV[_\x81\x90P\x91\x90PV[a\x12\x1Ba\x12\x16\x82a\r%V[a\x12\x01V[\x82RPPV[_\x81``\x1B\x90P\x91\x90PV[_a\x127\x82a\x12!V[\x90P\x91\x90PV[_a\x12H\x82a\x12-V[\x90P\x91\x90PV[a\x12`a\x12[\x82a\rwV[a\x12>V[\x82RPPV[_\x81\x90P\x91\x90PV[a\x12\x80a\x12{\x82a\r\xB2V[a\x12fV[\x82RPPV[_a\x12\x91\x82\x88a\x12\nV[` \x82\x01\x91Pa\x12\xA1\x82\x87a\x12OV[`\x14\x82\x01\x91Pa\x12\xB1\x82\x86a\x12oV[` \x82\x01\x91Pa\x12\xC1\x82\x85a\x12OV[`\x14\x82\x01\x91Pa\x12\xD1\x82\x84a\x12oV[` \x82\x01\x91P\x81\x90P\x96\x95PPPPPPV[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x11`\x04R`$_\xFD[_a\x13\x1B\x82a\r\xB2V[\x91Pa\x13&\x83a\r\xB2V[\x92P\x82\x82\x01\x90P\x80\x82\x11\x15a\x13>Wa\x13=a\x12\xE4V[[\x92\x91PPV[\x7FChallenge already claimed\0\0\0\0\0\0\0_\x82\x01RPV[_a\x13x`\x19\x83a\x11!V[\x91Pa\x13\x83\x82a\x13DV[` \x82\x01\x90P\x91\x90PV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01Ra\x13\xA5\x81a\x13lV[\x90P\x91\x90PV[\x7FOnly intended responder can clai_\x82\x01R\x7Fm\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0` \x82\x01RPV[_a\x14\x06`!\x83a\x11!V[\x91Pa\x14\x11\x82a\x13\xACV[`@\x82\x01\x90P\x91\x90PV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01Ra\x143\x81a\x13\xFAV[\x90P\x91\x90PV[_\x81\x90P\x92\x91PPV[\x82\x81\x837_\x83\x83\x01RPPPV[_a\x14]\x83\x85a\x14:V[\x93Pa\x14j\x83\x85\x84a\x14DV[\x82\x84\x01\x90P\x93\x92PPPV[_a\x14\x82\x82\x84\x86a\x14RV[\x91P\x81\x90P\x93\x92PPPV[\x7FIncorrect preimage\0\0\0\0\0\0\0\0\0\0\0\0\0\0_\x82\x01RPV[_a\x14\xC2`\x12\x83a\x11!V[\x91Pa\x14\xCD\x82a\x14\x8EV[` \x82\x01\x90P\x91\x90PV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01Ra\x14\xEF\x81a\x14\xB6V[\x90P\x91\x90PV[\x7FInvalid reward amount\0\0\0\0\0\0\0\0\0\0\0_\x82\x01RPV[_a\x15*`\x15\x83a\x11!V[\x91Pa\x155\x82a\x14\xF6V[` \x82\x01\x90P\x91\x90PV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01Ra\x15W\x81a\x15\x1EV[\x90P\x91\x90PV[PV[_a\x15l_\x83a\x14:V[\x91Pa\x15w\x82a\x15^V[_\x82\x01\x90P\x91\x90PV[_a\x15\x8B\x82a\x15aV[\x91P\x81\x90P\x91\x90PV[\x7FTransfer failed\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_\x82\x01RPV[_a\x15\xC9`\x0F\x83a\x11!V[\x91Pa\x15\xD4\x82a\x15\x95V[` \x82\x01\x90P\x91\x90PV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01Ra\x15\xF6\x81a\x15\xBDV[\x90P\x91\x90PV[_`@\x82\x01\x90Pa\x16\x10_\x83\x01\x85a\x0E\x92V[a\x16\x1D` \x83\x01\x84a\x0E\x92V[\x93\x92PPPV[\x7FOnly challenger can refund\0\0\0\0\0\0_\x82\x01RPV[_a\x16X`\x1A\x83a\x11!V[\x91Pa\x16c\x82a\x16$V[` \x82\x01\x90P\x91\x90PV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01Ra\x16\x85\x81a\x16LV[\x90P\x91\x90PV[_a\x16\x96\x82a\r\xB2V[\x91Pa\x16\xA1\x83a\r\xB2V[\x92P\x82\x82\x03\x90P\x81\x81\x11\x15a\x16\xB9Wa\x16\xB8a\x12\xE4V[[\x92\x91PPV[\x7FCannot refund more than the amou_\x82\x01R\x7Fnt remaining after claiming\0\0\0\0\0` \x82\x01RPV[_a\x17\x19`;\x83a\x11!V[\x91Pa\x17$\x82a\x16\xBFV[`@\x82\x01\x90P\x91\x90PV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01Ra\x17F\x81a\x17\rV[\x90P\x91\x90PV[\x7FRefund failed\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_\x82\x01RPV[_a\x17\x81`\r\x83a\x11!V[\x91Pa\x17\x8C\x82a\x17MV[` \x82\x01\x90P\x91\x90PV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01Ra\x17\xAE\x81a\x17uV[\x90P\x91\x90PV[_a\x17\xBF\x82a\r\xB2V[\x91Pa\x17\xCA\x83a\r\xB2V[\x92P\x82\x82\x02a\x17\xD8\x81a\r\xB2V[\x91P\x82\x82\x04\x84\x14\x83\x15\x17a\x17\xEFWa\x17\xEEa\x12\xE4V[[P\x92\x91PPV[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x12`\x04R`$_\xFD[_a\x18-\x82a\r\xB2V[\x91Pa\x188\x83a\r\xB2V[\x92P\x82a\x18HWa\x18Ga\x17\xF6V[[\x82\x82\x04\x90P\x92\x91PPV[_\x81\x15\x15\x90P\x91\x90PV[a\x18g\x81a\x18SV[\x82RPPV[_` \x82\x01\x90Pa\x18\x80_\x83\x01\x84a\x18^V[\x92\x91PPV[_\x81Q\x90P\x91\x90PV[\x82\x81\x83^_\x83\x83\x01RPPPV[_a\x18\xA8\x82a\x18\x86V[a\x18\xB2\x81\x85a\x14:V[\x93Pa\x18\xC2\x81\x85` \x86\x01a\x18\x90V[\x80\x84\x01\x91PP\x92\x91PPV[_a\x18\xD9\x82\x84a\x18\x9EV[\x91P\x81\x90P\x92\x91PPV\xFEMore than claimed delay has passed",
    );
    /// The runtime bytecode of the contract, as deployed on the network.
    ///
    /// ```text
    ///0x60806040526004361061006f575f3560e01c806385fa74bc1161004d57806385fa74bc146100fa5780638f1d377614610122578063a8e62b9714610166578063b973e1bf146101a25761006f565b806308e51b51146100735780631bdd4b741461008f5780632736d0b5146100d2575b5f5ffd5b61008d60048036038101906100889190610de5565b6101de565b005b34801561009a575f5ffd5b506100b560048036038101906100b09190610e49565b61049d565b6040516100c9989796959493929190610ea1565b60405180910390f35b3480156100dd575f5ffd5b506100f860048036038101906100f39190610f7e565b610539565b005b348015610105575f5ffd5b50610120600480360381019061011b9190610fef565b61084c565b005b34801561012d575f5ffd5b5061014860048036038101906101439190610e49565b610ad9565b60405161015d9998979695949392919061102d565b60405180910390f35b348015610171575f5ffd5b5061018c600480360381019061018791906110b8565b610b60565b6040516101999190611108565b60405180910390f35b3480156101ad575f5ffd5b506101c860048036038101906101c39190610e49565b610bca565b6040516101d59190611108565b60405180910390f35b5f3411610220576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016102179061117b565b60405180910390fd5b5f73ffffffffffffffffffffffffffffffffffffffff168373ffffffffffffffffffffffffffffffffffffffff160361028e576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610285906111e3565b60405180910390fd5b5f84848433856040516020016102a8959493929190611286565b604051602081830303815290604052805190602001205f1c90506040518061012001604052808681526020013373ffffffffffffffffffffffffffffffffffffffff1681526020018573ffffffffffffffffffffffffffffffffffffffff1681526020015f5f8481526020019081526020015f20600301543461032b9190611311565b81526020014281526020018481526020015f81526020015f8152602001838152505f5f8381526020019081526020015f205f820151815f01556020820151816001015f6101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055506040820151816002015f6101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff160217905550606082015181600301556080820151816004015560a0820151816005015560c0820151816006015560e0820151816007015561010082015181600801559050508373ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff16827fd2f7931a802085b3d0234d4c320ce7ee0041da96678ce2bf5c93e8d3d7e65f523460405161048e9190611108565b60405180910390a45050505050565b5f5f5f5f5f5f5f5f5f5f5f8b81526020019081526020015f209050805f0154816001015f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff16826002015f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff16836003015484600401548560050154866006015487600701549850985098509850985098509850985050919395975091939597565b5f5f5f8681526020019081526020015f2090505f816006015414610592576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016105899061138e565b60405180910390fd5b806002015f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff1614610623576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161061a9061141c565b60405180910390fd5b805f01548484604051610637929190611476565b60405180910390201461067f576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610676906114d8565b60405180910390fd5b5f8282600401546106909190611311565b90506106b4816040518060600160405280602281526020016118e560229139610c53565b5f6106c88484600501548560030154610b60565b90505f81101580156106de575082600301548111155b61071d576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161071490611540565b60405180910390fd5b8083600601819055505f836002015f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168260405161076e90611581565b5f6040518083038185875af1925050503d805f81146107a8576040519150601f19603f3d011682016040523d82523d5f602084013e6107ad565b606091505b50509050806107f1576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016107e8906115df565b60405180910390fd5b3373ffffffffffffffffffffffffffffffffffffffff16887f159b7bbdc606f37a40c138c8f053799889cf7524da20f9a31516f565659e349b848860405161083a9291906115fd565b60405180910390a35050505050505050565b5f5f8381526020019081526020015f206001015f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff16146108ec576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016108e39061166e565b60405180910390fd5b5f5f5f8481526020019081526020015f209050610951816005015482600401546109169190611311565b6040518060400160405280601e81526020017f43616e6e6f7420726566756e64206265666f7265206d61782064656c61790000815250610c63565b8060070154826109619190611311565b81600601548260030154610975919061168c565b10156109b6576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016109ad9061172f565b60405180910390fd5b5f816001015f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16836040516109fe90611581565b5f6040518083038185875af1925050503d805f8114610a38576040519150601f19603f3d011682016040523d82523d5f602084013e610a3d565b606091505b5050905080610a81576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610a7890611797565b60405180910390fd5b82826007015f828254610a949190611311565b92505081905550837f357c93e6bcb7005a62241e85838053bf0d968f2940a9bfd253d9e4b121a6bbe084604051610acb9190611108565b60405180910390a250505050565b5f602052805f5260405f205f91509050805f015490806001015f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1690806002015f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff16908060030154908060040154908060050154908060060154908060070154908060080154905089565b5f5f838510610b6f5783610b71565b845b90505f84670de0b6b3a76400008387610b8a919061168c565b610b9491906117b5565b610b9e9190611823565b9050670de0b6b3a76400008185610bb591906117b5565b610bbf9190611823565b925050509392505050565b5f5f5f5f8481526020019081526020015f2090505f816006015414610c24576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610c1b9061138e565b60405180910390fd5b5f816004015442610c35919061168c565b9050610c4a8183600501548460030154610b60565b92505050919050565b610c5f82421082610c73565b5050565b610c6f82421182610c73565b5050565b7f3dcdf63b41c103567d7225976ad9145e866c7a7dccc6c277ea86abbd268fbac95f1c73ffffffffffffffffffffffffffffffffffffffff1682604051602001610cbd919061186d565b604051602081830303815290604052604051610cd991906118ce565b5f60405180830381855afa9150503d805f8114610d11576040519150601f19603f3d011682016040523d82523d5f602084013e610d16565b606091505b5050505050565b5f5ffd5b5f5ffd5b5f819050919050565b610d3781610d25565b8114610d41575f5ffd5b50565b5f81359050610d5281610d2e565b92915050565b5f73ffffffffffffffffffffffffffffffffffffffff82169050919050565b5f610d8182610d58565b9050919050565b610d9181610d77565b8114610d9b575f5ffd5b50565b5f81359050610dac81610d88565b92915050565b5f819050919050565b610dc481610db2565b8114610dce575f5ffd5b50565b5f81359050610ddf81610dbb565b92915050565b5f5f5f5f60808587031215610dfd57610dfc610d1d565b5b5f610e0a87828801610d44565b9450506020610e1b87828801610d9e565b9350506040610e2c87828801610dd1565b9250506060610e3d87828801610dd1565b91505092959194509250565b5f60208284031215610e5e57610e5d610d1d565b5b5f610e6b84828501610dd1565b91505092915050565b610e7d81610d25565b82525050565b610e8c81610d77565b82525050565b610e9b81610db2565b82525050565b5f61010082019050610eb55f83018b610e74565b610ec2602083018a610e83565b610ecf6040830189610e83565b610edc6060830188610e92565b610ee96080830187610e92565b610ef660a0830186610e92565b610f0360c0830185610e92565b610f1060e0830184610e92565b9998505050505050505050565b5f5ffd5b5f5ffd5b5f5ffd5b5f5f83601f840112610f3e57610f3d610f1d565b5b8235905067ffffffffffffffff811115610f5b57610f5a610f21565b5b602083019150836001820283011115610f7757610f76610f25565b5b9250929050565b5f5f5f5f60608587031215610f9657610f95610d1d565b5b5f610fa387828801610dd1565b945050602085013567ffffffffffffffff811115610fc457610fc3610d21565b5b610fd087828801610f29565b93509350506040610fe387828801610dd1565b91505092959194509250565b5f5f6040838503121561100557611004610d1d565b5b5f61101285828601610dd1565b925050602061102385828601610dd1565b9150509250929050565b5f610120820190506110415f83018c610e74565b61104e602083018b610e83565b61105b604083018a610e83565b6110686060830189610e92565b6110756080830188610e92565b61108260a0830187610e92565b61108f60c0830186610e92565b61109c60e0830185610e92565b6110aa610100830184610e92565b9a9950505050505050505050565b5f5f5f606084860312156110cf576110ce610d1d565b5b5f6110dc86828701610dd1565b93505060206110ed86828701610dd1565b92505060406110fe86828701610dd1565b9150509250925092565b5f60208201905061111b5f830184610e92565b92915050565b5f82825260208201905092915050565b7f526577617264206d7573742062652067726561746572207468616e20300000005f82015250565b5f611165601d83611121565b915061117082611131565b602082019050919050565b5f6020820190508181035f83015261119281611159565b9050919050565b7f526573706f6e6465722063616e6e6f74206265207a65726f20616464726573735f82015250565b5f6111cd602083611121565b91506111d882611199565b602082019050919050565b5f6020820190508181035f8301526111fa816111c1565b9050919050565b5f819050919050565b61121b61121682610d25565b611201565b82525050565b5f8160601b9050919050565b5f61123782611221565b9050919050565b5f6112488261122d565b9050919050565b61126061125b82610d77565b61123e565b82525050565b5f819050919050565b61128061127b82610db2565b611266565b82525050565b5f611291828861120a565b6020820191506112a1828761124f565b6014820191506112b1828661126f565b6020820191506112c1828561124f565b6014820191506112d1828461126f565b6020820191508190509695505050505050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52601160045260245ffd5b5f61131b82610db2565b915061132683610db2565b925082820190508082111561133e5761133d6112e4565b5b92915050565b7f4368616c6c656e676520616c726561647920636c61696d6564000000000000005f82015250565b5f611378601983611121565b915061138382611344565b602082019050919050565b5f6020820190508181035f8301526113a58161136c565b9050919050565b7f4f6e6c7920696e74656e64656420726573706f6e6465722063616e20636c61695f8201527f6d00000000000000000000000000000000000000000000000000000000000000602082015250565b5f611406602183611121565b9150611411826113ac565b604082019050919050565b5f6020820190508181035f830152611433816113fa565b9050919050565b5f81905092915050565b828183375f83830152505050565b5f61145d838561143a565b935061146a838584611444565b82840190509392505050565b5f611482828486611452565b91508190509392505050565b7f496e636f727265637420707265696d61676500000000000000000000000000005f82015250565b5f6114c2601283611121565b91506114cd8261148e565b602082019050919050565b5f6020820190508181035f8301526114ef816114b6565b9050919050565b7f496e76616c69642072657761726420616d6f756e7400000000000000000000005f82015250565b5f61152a601583611121565b9150611535826114f6565b602082019050919050565b5f6020820190508181035f8301526115578161151e565b9050919050565b50565b5f61156c5f8361143a565b91506115778261155e565b5f82019050919050565b5f61158b82611561565b9150819050919050565b7f5472616e73666572206661696c656400000000000000000000000000000000005f82015250565b5f6115c9600f83611121565b91506115d482611595565b602082019050919050565b5f6020820190508181035f8301526115f6816115bd565b9050919050565b5f6040820190506116105f830185610e92565b61161d6020830184610e92565b9392505050565b7f4f6e6c79206368616c6c656e6765722063616e20726566756e640000000000005f82015250565b5f611658601a83611121565b915061166382611624565b602082019050919050565b5f6020820190508181035f8301526116858161164c565b9050919050565b5f61169682610db2565b91506116a183610db2565b92508282039050818111156116b9576116b86112e4565b5b92915050565b7f43616e6e6f7420726566756e64206d6f7265207468616e2074686520616d6f755f8201527f6e742072656d61696e696e6720616674657220636c61696d696e670000000000602082015250565b5f611719603b83611121565b9150611724826116bf565b604082019050919050565b5f6020820190508181035f8301526117468161170d565b9050919050565b7f526566756e64206661696c6564000000000000000000000000000000000000005f82015250565b5f611781600d83611121565b915061178c8261174d565b602082019050919050565b5f6020820190508181035f8301526117ae81611775565b9050919050565b5f6117bf82610db2565b91506117ca83610db2565b92508282026117d881610db2565b915082820484148315176117ef576117ee6112e4565b5b5092915050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52601260045260245ffd5b5f61182d82610db2565b915061183883610db2565b925082611848576118476117f6565b5b828204905092915050565b5f8115159050919050565b61186781611853565b82525050565b5f6020820190506118805f83018461185e565b92915050565b5f81519050919050565b8281835e5f83830152505050565b5f6118a882611886565b6118b2818561143a565b93506118c2818560208601611890565b80840191505092915050565b5f6118d9828461189e565b91508190509291505056fe4d6f7265207468616e20636c61696d65642064656c61792068617320706173736564
    /// ```
    #[rustfmt::skip]
    #[allow(clippy::all)]
    pub static DEPLOYED_BYTECODE: alloy_sol_types::private::Bytes = alloy_sol_types::private::Bytes::from_static(
        b"`\x80`@R`\x046\x10a\0oW_5`\xE0\x1C\x80c\x85\xFAt\xBC\x11a\0MW\x80c\x85\xFAt\xBC\x14a\0\xFAW\x80c\x8F\x1D7v\x14a\x01\"W\x80c\xA8\xE6+\x97\x14a\x01fW\x80c\xB9s\xE1\xBF\x14a\x01\xA2Wa\0oV[\x80c\x08\xE5\x1BQ\x14a\0sW\x80c\x1B\xDDKt\x14a\0\x8FW\x80c'6\xD0\xB5\x14a\0\xD2W[__\xFD[a\0\x8D`\x04\x806\x03\x81\x01\x90a\0\x88\x91\x90a\r\xE5V[a\x01\xDEV[\0[4\x80\x15a\0\x9AW__\xFD[Pa\0\xB5`\x04\x806\x03\x81\x01\x90a\0\xB0\x91\x90a\x0EIV[a\x04\x9DV[`@Qa\0\xC9\x98\x97\x96\x95\x94\x93\x92\x91\x90a\x0E\xA1V[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\0\xDDW__\xFD[Pa\0\xF8`\x04\x806\x03\x81\x01\x90a\0\xF3\x91\x90a\x0F~V[a\x059V[\0[4\x80\x15a\x01\x05W__\xFD[Pa\x01 `\x04\x806\x03\x81\x01\x90a\x01\x1B\x91\x90a\x0F\xEFV[a\x08LV[\0[4\x80\x15a\x01-W__\xFD[Pa\x01H`\x04\x806\x03\x81\x01\x90a\x01C\x91\x90a\x0EIV[a\n\xD9V[`@Qa\x01]\x99\x98\x97\x96\x95\x94\x93\x92\x91\x90a\x10-V[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x01qW__\xFD[Pa\x01\x8C`\x04\x806\x03\x81\x01\x90a\x01\x87\x91\x90a\x10\xB8V[a\x0B`V[`@Qa\x01\x99\x91\x90a\x11\x08V[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x01\xADW__\xFD[Pa\x01\xC8`\x04\x806\x03\x81\x01\x90a\x01\xC3\x91\x90a\x0EIV[a\x0B\xCAV[`@Qa\x01\xD5\x91\x90a\x11\x08V[`@Q\x80\x91\x03\x90\xF3[_4\x11a\x02 W`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x02\x17\x90a\x11{V[`@Q\x80\x91\x03\x90\xFD[_s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x83s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x03a\x02\x8EW`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x02\x85\x90a\x11\xE3V[`@Q\x80\x91\x03\x90\xFD[_\x84\x84\x843\x85`@Q` \x01a\x02\xA8\x95\x94\x93\x92\x91\x90a\x12\x86V[`@Q` \x81\x83\x03\x03\x81R\x90`@R\x80Q\x90` \x01 _\x1C\x90P`@Q\x80a\x01 \x01`@R\x80\x86\x81R` \x013s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x85s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01__\x84\x81R` \x01\x90\x81R` \x01_ `\x03\x01T4a\x03+\x91\x90a\x13\x11V[\x81R` \x01B\x81R` \x01\x84\x81R` \x01_\x81R` \x01_\x81R` \x01\x83\x81RP__\x83\x81R` \x01\x90\x81R` \x01_ _\x82\x01Q\x81_\x01U` \x82\x01Q\x81`\x01\x01_a\x01\0\n\x81T\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x02\x17\x90UP`@\x82\x01Q\x81`\x02\x01_a\x01\0\n\x81T\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x02\x17\x90UP``\x82\x01Q\x81`\x03\x01U`\x80\x82\x01Q\x81`\x04\x01U`\xA0\x82\x01Q\x81`\x05\x01U`\xC0\x82\x01Q\x81`\x06\x01U`\xE0\x82\x01Q\x81`\x07\x01Ua\x01\0\x82\x01Q\x81`\x08\x01U\x90PP\x83s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x163s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x82\x7F\xD2\xF7\x93\x1A\x80 \x85\xB3\xD0#ML2\x0C\xE7\xEE\0A\xDA\x96g\x8C\xE2\xBF\\\x93\xE8\xD3\xD7\xE6_R4`@Qa\x04\x8E\x91\x90a\x11\x08V[`@Q\x80\x91\x03\x90\xA4PPPPPV[___________\x8B\x81R` \x01\x90\x81R` \x01_ \x90P\x80_\x01T\x81`\x01\x01_\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x82`\x02\x01_\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x83`\x03\x01T\x84`\x04\x01T\x85`\x05\x01T\x86`\x06\x01T\x87`\x07\x01T\x98P\x98P\x98P\x98P\x98P\x98P\x98P\x98PP\x91\x93\x95\x97P\x91\x93\x95\x97V[___\x86\x81R` \x01\x90\x81R` \x01_ \x90P_\x81`\x06\x01T\x14a\x05\x92W`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x05\x89\x90a\x13\x8EV[`@Q\x80\x91\x03\x90\xFD[\x80`\x02\x01_\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x163s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14a\x06#W`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x06\x1A\x90a\x14\x1CV[`@Q\x80\x91\x03\x90\xFD[\x80_\x01T\x84\x84`@Qa\x067\x92\x91\x90a\x14vV[`@Q\x80\x91\x03\x90 \x14a\x06\x7FW`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x06v\x90a\x14\xD8V[`@Q\x80\x91\x03\x90\xFD[_\x82\x82`\x04\x01Ta\x06\x90\x91\x90a\x13\x11V[\x90Pa\x06\xB4\x81`@Q\x80``\x01`@R\x80`\"\x81R` \x01a\x18\xE5`\"\x919a\x0CSV[_a\x06\xC8\x84\x84`\x05\x01T\x85`\x03\x01Ta\x0B`V[\x90P_\x81\x10\x15\x80\x15a\x06\xDEWP\x82`\x03\x01T\x81\x11\x15[a\x07\x1DW`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x07\x14\x90a\x15@V[`@Q\x80\x91\x03\x90\xFD[\x80\x83`\x06\x01\x81\x90UP_\x83`\x02\x01_\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x82`@Qa\x07n\x90a\x15\x81V[_`@Q\x80\x83\x03\x81\x85\x87Z\xF1\x92PPP=\x80_\x81\x14a\x07\xA8W`@Q\x91P`\x1F\x19`?=\x01\x16\x82\x01`@R=\x82R=_` \x84\x01>a\x07\xADV[``\x91P[PP\x90P\x80a\x07\xF1W`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x07\xE8\x90a\x15\xDFV[`@Q\x80\x91\x03\x90\xFD[3s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x88\x7F\x15\x9B{\xBD\xC6\x06\xF3z@\xC18\xC8\xF0Sy\x98\x89\xCFu$\xDA \xF9\xA3\x15\x16\xF5ee\x9E4\x9B\x84\x88`@Qa\x08:\x92\x91\x90a\x15\xFDV[`@Q\x80\x91\x03\x90\xA3PPPPPPPPV[__\x83\x81R` \x01\x90\x81R` \x01_ `\x01\x01_\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x163s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14a\x08\xECW`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x08\xE3\x90a\x16nV[`@Q\x80\x91\x03\x90\xFD[___\x84\x81R` \x01\x90\x81R` \x01_ \x90Pa\tQ\x81`\x05\x01T\x82`\x04\x01Ta\t\x16\x91\x90a\x13\x11V[`@Q\x80`@\x01`@R\x80`\x1E\x81R` \x01\x7FCannot refund before max delay\0\0\x81RPa\x0CcV[\x80`\x07\x01T\x82a\ta\x91\x90a\x13\x11V[\x81`\x06\x01T\x82`\x03\x01Ta\tu\x91\x90a\x16\x8CV[\x10\x15a\t\xB6W`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\t\xAD\x90a\x17/V[`@Q\x80\x91\x03\x90\xFD[_\x81`\x01\x01_\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x83`@Qa\t\xFE\x90a\x15\x81V[_`@Q\x80\x83\x03\x81\x85\x87Z\xF1\x92PPP=\x80_\x81\x14a\n8W`@Q\x91P`\x1F\x19`?=\x01\x16\x82\x01`@R=\x82R=_` \x84\x01>a\n=V[``\x91P[PP\x90P\x80a\n\x81W`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\nx\x90a\x17\x97V[`@Q\x80\x91\x03\x90\xFD[\x82\x82`\x07\x01_\x82\x82Ta\n\x94\x91\x90a\x13\x11V[\x92PP\x81\x90UP\x83\x7F5|\x93\xE6\xBC\xB7\0Zb$\x1E\x85\x83\x80S\xBF\r\x96\x8F)@\xA9\xBF\xD2S\xD9\xE4\xB1!\xA6\xBB\xE0\x84`@Qa\n\xCB\x91\x90a\x11\x08V[`@Q\x80\x91\x03\x90\xA2PPPPV[_` R\x80_R`@_ _\x91P\x90P\x80_\x01T\x90\x80`\x01\x01_\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90\x80`\x02\x01_\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90\x80`\x03\x01T\x90\x80`\x04\x01T\x90\x80`\x05\x01T\x90\x80`\x06\x01T\x90\x80`\x07\x01T\x90\x80`\x08\x01T\x90P\x89V[__\x83\x85\x10a\x0BoW\x83a\x0BqV[\x84[\x90P_\x84g\r\xE0\xB6\xB3\xA7d\0\0\x83\x87a\x0B\x8A\x91\x90a\x16\x8CV[a\x0B\x94\x91\x90a\x17\xB5V[a\x0B\x9E\x91\x90a\x18#V[\x90Pg\r\xE0\xB6\xB3\xA7d\0\0\x81\x85a\x0B\xB5\x91\x90a\x17\xB5V[a\x0B\xBF\x91\x90a\x18#V[\x92PPP\x93\x92PPPV[____\x84\x81R` \x01\x90\x81R` \x01_ \x90P_\x81`\x06\x01T\x14a\x0C$W`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x0C\x1B\x90a\x13\x8EV[`@Q\x80\x91\x03\x90\xFD[_\x81`\x04\x01TBa\x0C5\x91\x90a\x16\x8CV[\x90Pa\x0CJ\x81\x83`\x05\x01T\x84`\x03\x01Ta\x0B`V[\x92PPP\x91\x90PV[a\x0C_\x82B\x10\x82a\x0CsV[PPV[a\x0Co\x82B\x11\x82a\x0CsV[PPV[\x7F=\xCD\xF6;A\xC1\x03V}r%\x97j\xD9\x14^\x86lz}\xCC\xC6\xC2w\xEA\x86\xAB\xBD&\x8F\xBA\xC9_\x1Cs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x82`@Q` \x01a\x0C\xBD\x91\x90a\x18mV[`@Q` \x81\x83\x03\x03\x81R\x90`@R`@Qa\x0C\xD9\x91\x90a\x18\xCEV[_`@Q\x80\x83\x03\x81\x85Z\xFA\x91PP=\x80_\x81\x14a\r\x11W`@Q\x91P`\x1F\x19`?=\x01\x16\x82\x01`@R=\x82R=_` \x84\x01>a\r\x16V[``\x91P[PPPPPV[__\xFD[__\xFD[_\x81\x90P\x91\x90PV[a\r7\x81a\r%V[\x81\x14a\rAW__\xFD[PV[_\x815\x90Pa\rR\x81a\r.V[\x92\x91PPV[_s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x16\x90P\x91\x90PV[_a\r\x81\x82a\rXV[\x90P\x91\x90PV[a\r\x91\x81a\rwV[\x81\x14a\r\x9BW__\xFD[PV[_\x815\x90Pa\r\xAC\x81a\r\x88V[\x92\x91PPV[_\x81\x90P\x91\x90PV[a\r\xC4\x81a\r\xB2V[\x81\x14a\r\xCEW__\xFD[PV[_\x815\x90Pa\r\xDF\x81a\r\xBBV[\x92\x91PPV[____`\x80\x85\x87\x03\x12\x15a\r\xFDWa\r\xFCa\r\x1DV[[_a\x0E\n\x87\x82\x88\x01a\rDV[\x94PP` a\x0E\x1B\x87\x82\x88\x01a\r\x9EV[\x93PP`@a\x0E,\x87\x82\x88\x01a\r\xD1V[\x92PP``a\x0E=\x87\x82\x88\x01a\r\xD1V[\x91PP\x92\x95\x91\x94P\x92PV[_` \x82\x84\x03\x12\x15a\x0E^Wa\x0E]a\r\x1DV[[_a\x0Ek\x84\x82\x85\x01a\r\xD1V[\x91PP\x92\x91PPV[a\x0E}\x81a\r%V[\x82RPPV[a\x0E\x8C\x81a\rwV[\x82RPPV[a\x0E\x9B\x81a\r\xB2V[\x82RPPV[_a\x01\0\x82\x01\x90Pa\x0E\xB5_\x83\x01\x8Ba\x0EtV[a\x0E\xC2` \x83\x01\x8Aa\x0E\x83V[a\x0E\xCF`@\x83\x01\x89a\x0E\x83V[a\x0E\xDC``\x83\x01\x88a\x0E\x92V[a\x0E\xE9`\x80\x83\x01\x87a\x0E\x92V[a\x0E\xF6`\xA0\x83\x01\x86a\x0E\x92V[a\x0F\x03`\xC0\x83\x01\x85a\x0E\x92V[a\x0F\x10`\xE0\x83\x01\x84a\x0E\x92V[\x99\x98PPPPPPPPPV[__\xFD[__\xFD[__\xFD[__\x83`\x1F\x84\x01\x12a\x0F>Wa\x0F=a\x0F\x1DV[[\x825\x90Pg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\x0F[Wa\x0FZa\x0F!V[[` \x83\x01\x91P\x83`\x01\x82\x02\x83\x01\x11\x15a\x0FwWa\x0Fva\x0F%V[[\x92P\x92\x90PV[____``\x85\x87\x03\x12\x15a\x0F\x96Wa\x0F\x95a\r\x1DV[[_a\x0F\xA3\x87\x82\x88\x01a\r\xD1V[\x94PP` \x85\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\x0F\xC4Wa\x0F\xC3a\r!V[[a\x0F\xD0\x87\x82\x88\x01a\x0F)V[\x93P\x93PP`@a\x0F\xE3\x87\x82\x88\x01a\r\xD1V[\x91PP\x92\x95\x91\x94P\x92PV[__`@\x83\x85\x03\x12\x15a\x10\x05Wa\x10\x04a\r\x1DV[[_a\x10\x12\x85\x82\x86\x01a\r\xD1V[\x92PP` a\x10#\x85\x82\x86\x01a\r\xD1V[\x91PP\x92P\x92\x90PV[_a\x01 \x82\x01\x90Pa\x10A_\x83\x01\x8Ca\x0EtV[a\x10N` \x83\x01\x8Ba\x0E\x83V[a\x10[`@\x83\x01\x8Aa\x0E\x83V[a\x10h``\x83\x01\x89a\x0E\x92V[a\x10u`\x80\x83\x01\x88a\x0E\x92V[a\x10\x82`\xA0\x83\x01\x87a\x0E\x92V[a\x10\x8F`\xC0\x83\x01\x86a\x0E\x92V[a\x10\x9C`\xE0\x83\x01\x85a\x0E\x92V[a\x10\xAAa\x01\0\x83\x01\x84a\x0E\x92V[\x9A\x99PPPPPPPPPPV[___``\x84\x86\x03\x12\x15a\x10\xCFWa\x10\xCEa\r\x1DV[[_a\x10\xDC\x86\x82\x87\x01a\r\xD1V[\x93PP` a\x10\xED\x86\x82\x87\x01a\r\xD1V[\x92PP`@a\x10\xFE\x86\x82\x87\x01a\r\xD1V[\x91PP\x92P\x92P\x92V[_` \x82\x01\x90Pa\x11\x1B_\x83\x01\x84a\x0E\x92V[\x92\x91PPV[_\x82\x82R` \x82\x01\x90P\x92\x91PPV[\x7FReward must be greater than 0\0\0\0_\x82\x01RPV[_a\x11e`\x1D\x83a\x11!V[\x91Pa\x11p\x82a\x111V[` \x82\x01\x90P\x91\x90PV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01Ra\x11\x92\x81a\x11YV[\x90P\x91\x90PV[\x7FResponder cannot be zero address_\x82\x01RPV[_a\x11\xCD` \x83a\x11!V[\x91Pa\x11\xD8\x82a\x11\x99V[` \x82\x01\x90P\x91\x90PV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01Ra\x11\xFA\x81a\x11\xC1V[\x90P\x91\x90PV[_\x81\x90P\x91\x90PV[a\x12\x1Ba\x12\x16\x82a\r%V[a\x12\x01V[\x82RPPV[_\x81``\x1B\x90P\x91\x90PV[_a\x127\x82a\x12!V[\x90P\x91\x90PV[_a\x12H\x82a\x12-V[\x90P\x91\x90PV[a\x12`a\x12[\x82a\rwV[a\x12>V[\x82RPPV[_\x81\x90P\x91\x90PV[a\x12\x80a\x12{\x82a\r\xB2V[a\x12fV[\x82RPPV[_a\x12\x91\x82\x88a\x12\nV[` \x82\x01\x91Pa\x12\xA1\x82\x87a\x12OV[`\x14\x82\x01\x91Pa\x12\xB1\x82\x86a\x12oV[` \x82\x01\x91Pa\x12\xC1\x82\x85a\x12OV[`\x14\x82\x01\x91Pa\x12\xD1\x82\x84a\x12oV[` \x82\x01\x91P\x81\x90P\x96\x95PPPPPPV[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x11`\x04R`$_\xFD[_a\x13\x1B\x82a\r\xB2V[\x91Pa\x13&\x83a\r\xB2V[\x92P\x82\x82\x01\x90P\x80\x82\x11\x15a\x13>Wa\x13=a\x12\xE4V[[\x92\x91PPV[\x7FChallenge already claimed\0\0\0\0\0\0\0_\x82\x01RPV[_a\x13x`\x19\x83a\x11!V[\x91Pa\x13\x83\x82a\x13DV[` \x82\x01\x90P\x91\x90PV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01Ra\x13\xA5\x81a\x13lV[\x90P\x91\x90PV[\x7FOnly intended responder can clai_\x82\x01R\x7Fm\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0` \x82\x01RPV[_a\x14\x06`!\x83a\x11!V[\x91Pa\x14\x11\x82a\x13\xACV[`@\x82\x01\x90P\x91\x90PV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01Ra\x143\x81a\x13\xFAV[\x90P\x91\x90PV[_\x81\x90P\x92\x91PPV[\x82\x81\x837_\x83\x83\x01RPPPV[_a\x14]\x83\x85a\x14:V[\x93Pa\x14j\x83\x85\x84a\x14DV[\x82\x84\x01\x90P\x93\x92PPPV[_a\x14\x82\x82\x84\x86a\x14RV[\x91P\x81\x90P\x93\x92PPPV[\x7FIncorrect preimage\0\0\0\0\0\0\0\0\0\0\0\0\0\0_\x82\x01RPV[_a\x14\xC2`\x12\x83a\x11!V[\x91Pa\x14\xCD\x82a\x14\x8EV[` \x82\x01\x90P\x91\x90PV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01Ra\x14\xEF\x81a\x14\xB6V[\x90P\x91\x90PV[\x7FInvalid reward amount\0\0\0\0\0\0\0\0\0\0\0_\x82\x01RPV[_a\x15*`\x15\x83a\x11!V[\x91Pa\x155\x82a\x14\xF6V[` \x82\x01\x90P\x91\x90PV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01Ra\x15W\x81a\x15\x1EV[\x90P\x91\x90PV[PV[_a\x15l_\x83a\x14:V[\x91Pa\x15w\x82a\x15^V[_\x82\x01\x90P\x91\x90PV[_a\x15\x8B\x82a\x15aV[\x91P\x81\x90P\x91\x90PV[\x7FTransfer failed\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_\x82\x01RPV[_a\x15\xC9`\x0F\x83a\x11!V[\x91Pa\x15\xD4\x82a\x15\x95V[` \x82\x01\x90P\x91\x90PV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01Ra\x15\xF6\x81a\x15\xBDV[\x90P\x91\x90PV[_`@\x82\x01\x90Pa\x16\x10_\x83\x01\x85a\x0E\x92V[a\x16\x1D` \x83\x01\x84a\x0E\x92V[\x93\x92PPPV[\x7FOnly challenger can refund\0\0\0\0\0\0_\x82\x01RPV[_a\x16X`\x1A\x83a\x11!V[\x91Pa\x16c\x82a\x16$V[` \x82\x01\x90P\x91\x90PV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01Ra\x16\x85\x81a\x16LV[\x90P\x91\x90PV[_a\x16\x96\x82a\r\xB2V[\x91Pa\x16\xA1\x83a\r\xB2V[\x92P\x82\x82\x03\x90P\x81\x81\x11\x15a\x16\xB9Wa\x16\xB8a\x12\xE4V[[\x92\x91PPV[\x7FCannot refund more than the amou_\x82\x01R\x7Fnt remaining after claiming\0\0\0\0\0` \x82\x01RPV[_a\x17\x19`;\x83a\x11!V[\x91Pa\x17$\x82a\x16\xBFV[`@\x82\x01\x90P\x91\x90PV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01Ra\x17F\x81a\x17\rV[\x90P\x91\x90PV[\x7FRefund failed\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_\x82\x01RPV[_a\x17\x81`\r\x83a\x11!V[\x91Pa\x17\x8C\x82a\x17MV[` \x82\x01\x90P\x91\x90PV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01Ra\x17\xAE\x81a\x17uV[\x90P\x91\x90PV[_a\x17\xBF\x82a\r\xB2V[\x91Pa\x17\xCA\x83a\r\xB2V[\x92P\x82\x82\x02a\x17\xD8\x81a\r\xB2V[\x91P\x82\x82\x04\x84\x14\x83\x15\x17a\x17\xEFWa\x17\xEEa\x12\xE4V[[P\x92\x91PPV[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x12`\x04R`$_\xFD[_a\x18-\x82a\r\xB2V[\x91Pa\x188\x83a\r\xB2V[\x92P\x82a\x18HWa\x18Ga\x17\xF6V[[\x82\x82\x04\x90P\x92\x91PPV[_\x81\x15\x15\x90P\x91\x90PV[a\x18g\x81a\x18SV[\x82RPPV[_` \x82\x01\x90Pa\x18\x80_\x83\x01\x84a\x18^V[\x92\x91PPV[_\x81Q\x90P\x91\x90PV[\x82\x81\x83^_\x83\x83\x01RPPPV[_a\x18\xA8\x82a\x18\x86V[a\x18\xB2\x81\x85a\x14:V[\x93Pa\x18\xC2\x81\x85` \x86\x01a\x18\x90V[\x80\x84\x01\x91PP\x92\x91PPV[_a\x18\xD9\x82\x84a\x18\x9EV[\x91P\x81\x90P\x92\x91PPV\xFEMore than claimed delay has passed",
    );
    /**Event with signature `ChallengeClaimed(uint256,address,uint256,uint256)` and selector `0x159b7bbdc606f37a40c138c8f053799889cf7524da20f9a31516f565659e349b`.
```solidity
event ChallengeClaimed(uint256 indexed challengeId, address indexed responder, uint256 rewardPaid, uint256 responseTime);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct ChallengeClaimed {
        #[allow(missing_docs)]
        pub challengeId: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub responder: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub rewardPaid: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub responseTime: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for ChallengeClaimed {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "ChallengeClaimed(uint256,address,uint256,uint256)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                21u8,
                155u8,
                123u8,
                189u8,
                198u8,
                6u8,
                243u8,
                122u8,
                64u8,
                193u8,
                56u8,
                200u8,
                240u8,
                83u8,
                121u8,
                152u8,
                137u8,
                207u8,
                117u8,
                36u8,
                218u8,
                32u8,
                249u8,
                163u8,
                21u8,
                22u8,
                245u8,
                101u8,
                101u8,
                158u8,
                52u8,
                155u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    challengeId: topics.1,
                    responder: topics.2,
                    rewardPaid: data.0,
                    responseTime: data.1,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.rewardPaid),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.responseTime),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (
                    Self::SIGNATURE_HASH.into(),
                    self.challengeId.clone(),
                    self.responder.clone(),
                )
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.challengeId);
                out[2usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.responder,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for ChallengeClaimed {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&ChallengeClaimed> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &ChallengeClaimed) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `ChallengeCreated(uint256,address,address,uint256)` and selector `0xd2f7931a802085b3d0234d4c320ce7ee0041da96678ce2bf5c93e8d3d7e65f52`.
```solidity
event ChallengeCreated(uint256 indexed challengeId, address indexed challenger, address indexed responder, uint256 reward);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct ChallengeCreated {
        #[allow(missing_docs)]
        pub challengeId: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub challenger: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub responder: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub reward: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for ChallengeCreated {
            type DataTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "ChallengeCreated(uint256,address,address,uint256)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                210u8,
                247u8,
                147u8,
                26u8,
                128u8,
                32u8,
                133u8,
                179u8,
                208u8,
                35u8,
                77u8,
                76u8,
                50u8,
                12u8,
                231u8,
                238u8,
                0u8,
                65u8,
                218u8,
                150u8,
                103u8,
                140u8,
                226u8,
                191u8,
                92u8,
                147u8,
                232u8,
                211u8,
                215u8,
                230u8,
                95u8,
                82u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    challengeId: topics.1,
                    challenger: topics.2,
                    responder: topics.3,
                    reward: data.0,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.reward),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (
                    Self::SIGNATURE_HASH.into(),
                    self.challengeId.clone(),
                    self.challenger.clone(),
                    self.responder.clone(),
                )
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.challengeId);
                out[2usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.challenger,
                );
                out[3usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.responder,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for ChallengeCreated {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&ChallengeCreated> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &ChallengeCreated) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `ChallengeRefunded(uint256,uint256)` and selector `0x357c93e6bcb7005a62241e85838053bf0d968f2940a9bfd253d9e4b121a6bbe0`.
```solidity
event ChallengeRefunded(uint256 indexed challengeId, uint256 refundAmount);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct ChallengeRefunded {
        #[allow(missing_docs)]
        pub challengeId: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub refundAmount: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for ChallengeRefunded {
            type DataTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            const SIGNATURE: &'static str = "ChallengeRefunded(uint256,uint256)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                53u8,
                124u8,
                147u8,
                230u8,
                188u8,
                183u8,
                0u8,
                90u8,
                98u8,
                36u8,
                30u8,
                133u8,
                131u8,
                128u8,
                83u8,
                191u8,
                13u8,
                150u8,
                143u8,
                41u8,
                64u8,
                169u8,
                191u8,
                210u8,
                83u8,
                217u8,
                228u8,
                177u8,
                33u8,
                166u8,
                187u8,
                224u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    challengeId: topics.1,
                    refundAmount: data.0,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.refundAmount),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.challengeId.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.challengeId);
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for ChallengeRefunded {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&ChallengeRefunded> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &ChallengeRefunded) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Function with signature `calculateReward(uint256,uint256,uint256)` and selector `0xa8e62b97`.
```solidity
function calculateReward(uint256 elapsedTime, uint256 maxTime, uint256 totalReward) external pure returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct calculateRewardCall {
        #[allow(missing_docs)]
        pub elapsedTime: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub maxTime: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub totalReward: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`calculateReward(uint256,uint256,uint256)`](calculateRewardCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct calculateRewardReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<calculateRewardCall> for UnderlyingRustTuple<'_> {
                fn from(value: calculateRewardCall) -> Self {
                    (value.elapsedTime, value.maxTime, value.totalReward)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for calculateRewardCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        elapsedTime: tuple.0,
                        maxTime: tuple.1,
                        totalReward: tuple.2,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<calculateRewardReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: calculateRewardReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for calculateRewardReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for calculateRewardCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = calculateRewardReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "calculateReward(uint256,uint256,uint256)";
            const SELECTOR: [u8; 4] = [168u8, 230u8, 43u8, 151u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.elapsedTime),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.maxTime),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.totalReward),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `challenges(uint256)` and selector `0x8f1d3776`.
```solidity
function challenges(uint256) external view returns (bytes32 hash, address challenger, address responder, uint256 reward, uint256 creationTime, uint256 maxDelay, uint256 rewardedAmount, uint256 refundedAmount, uint256 sequenceNumber);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct challengesCall {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`challenges(uint256)`](challengesCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct challengesReturn {
        #[allow(missing_docs)]
        pub hash: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub challenger: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub responder: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub reward: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub creationTime: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub maxDelay: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub rewardedAmount: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub refundedAmount: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub sequenceNumber: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<challengesCall> for UnderlyingRustTuple<'_> {
                fn from(value: challengesCall) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for challengesCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::Address,
                alloy::sol_types::private::Address,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<challengesReturn> for UnderlyingRustTuple<'_> {
                fn from(value: challengesReturn) -> Self {
                    (
                        value.hash,
                        value.challenger,
                        value.responder,
                        value.reward,
                        value.creationTime,
                        value.maxDelay,
                        value.rewardedAmount,
                        value.refundedAmount,
                        value.sequenceNumber,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for challengesReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        hash: tuple.0,
                        challenger: tuple.1,
                        responder: tuple.2,
                        reward: tuple.3,
                        creationTime: tuple.4,
                        maxDelay: tuple.5,
                        rewardedAmount: tuple.6,
                        refundedAmount: tuple.7,
                        sequenceNumber: tuple.8,
                    }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for challengesCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = challengesReturn;
            type ReturnTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "challenges(uint256)";
            const SELECTOR: [u8; 4] = [143u8, 29u8, 55u8, 118u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self._0),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `claimChallenge(uint256,bytes,uint256)` and selector `0x2736d0b5`.
```solidity
function claimChallenge(uint256 challengeId, bytes memory preimage, uint256 claimedDelay) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claimChallengeCall {
        #[allow(missing_docs)]
        pub challengeId: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub preimage: alloy::sol_types::private::Bytes,
        #[allow(missing_docs)]
        pub claimedDelay: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`claimChallenge(uint256,bytes,uint256)`](claimChallengeCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claimChallengeReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Bytes,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::Bytes,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claimChallengeCall> for UnderlyingRustTuple<'_> {
                fn from(value: claimChallengeCall) -> Self {
                    (value.challengeId, value.preimage, value.claimedDelay)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for claimChallengeCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        challengeId: tuple.0,
                        preimage: tuple.1,
                        claimedDelay: tuple.2,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claimChallengeReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: claimChallengeReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for claimChallengeReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for claimChallengeCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Bytes,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = claimChallengeReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "claimChallenge(uint256,bytes,uint256)";
            const SELECTOR: [u8; 4] = [39u8, 54u8, 208u8, 181u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.challengeId),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.preimage,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.claimedDelay),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `createChallenge(bytes32,address,uint256,uint256)` and selector `0x08e51b51`.
```solidity
function createChallenge(bytes32 dataHash, address responder, uint256 maxDelay, uint256 sequenceNumber) external payable;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct createChallengeCall {
        #[allow(missing_docs)]
        pub dataHash: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub responder: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub maxDelay: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub sequenceNumber: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`createChallenge(bytes32,address,uint256,uint256)`](createChallengeCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct createChallengeReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::Address,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<createChallengeCall> for UnderlyingRustTuple<'_> {
                fn from(value: createChallengeCall) -> Self {
                    (
                        value.dataHash,
                        value.responder,
                        value.maxDelay,
                        value.sequenceNumber,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for createChallengeCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        dataHash: tuple.0,
                        responder: tuple.1,
                        maxDelay: tuple.2,
                        sequenceNumber: tuple.3,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<createChallengeReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: createChallengeReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for createChallengeReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for createChallengeCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = createChallengeReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "createChallenge(bytes32,address,uint256,uint256)";
            const SELECTOR: [u8; 4] = [8u8, 229u8, 27u8, 81u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.dataHash),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.responder,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.maxDelay),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.sequenceNumber),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `getChallenge(uint256)` and selector `0x1bdd4b74`.
```solidity
function getChallenge(uint256 challengeId) external view returns (bytes32 hash, address challenger, address responder, uint256 reward, uint256 creationTime, uint256 maxDelay, uint256 rewardedAmount, uint256 refundedAmount);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getChallengeCall {
        #[allow(missing_docs)]
        pub challengeId: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`getChallenge(uint256)`](getChallengeCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getChallengeReturn {
        #[allow(missing_docs)]
        pub hash: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub challenger: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub responder: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub reward: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub creationTime: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub maxDelay: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub rewardedAmount: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub refundedAmount: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getChallengeCall> for UnderlyingRustTuple<'_> {
                fn from(value: getChallengeCall) -> Self {
                    (value.challengeId,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getChallengeCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { challengeId: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::Address,
                alloy::sol_types::private::Address,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getChallengeReturn> for UnderlyingRustTuple<'_> {
                fn from(value: getChallengeReturn) -> Self {
                    (
                        value.hash,
                        value.challenger,
                        value.responder,
                        value.reward,
                        value.creationTime,
                        value.maxDelay,
                        value.rewardedAmount,
                        value.refundedAmount,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getChallengeReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        hash: tuple.0,
                        challenger: tuple.1,
                        responder: tuple.2,
                        reward: tuple.3,
                        creationTime: tuple.4,
                        maxDelay: tuple.5,
                        rewardedAmount: tuple.6,
                        refundedAmount: tuple.7,
                    }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getChallengeCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getChallengeReturn;
            type ReturnTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getChallenge(uint256)";
            const SELECTOR: [u8; 4] = [27u8, 221u8, 75u8, 116u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.challengeId),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `getRefund(uint256,uint256)` and selector `0x85fa74bc`.
```solidity
function getRefund(uint256 challengeId, uint256 refundAmount) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getRefundCall {
        #[allow(missing_docs)]
        pub challengeId: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub refundAmount: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`getRefund(uint256,uint256)`](getRefundCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getRefundReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getRefundCall> for UnderlyingRustTuple<'_> {
                fn from(value: getRefundCall) -> Self {
                    (value.challengeId, value.refundAmount)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getRefundCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        challengeId: tuple.0,
                        refundAmount: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getRefundReturn> for UnderlyingRustTuple<'_> {
                fn from(value: getRefundReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getRefundReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getRefundCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getRefundReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getRefund(uint256,uint256)";
            const SELECTOR: [u8; 4] = [133u8, 250u8, 116u8, 188u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.challengeId),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.refundAmount),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `previewReward(uint256)` and selector `0xb973e1bf`.
```solidity
function previewReward(uint256 challengeId) external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct previewRewardCall {
        #[allow(missing_docs)]
        pub challengeId: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`previewReward(uint256)`](previewRewardCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct previewRewardReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<previewRewardCall> for UnderlyingRustTuple<'_> {
                fn from(value: previewRewardCall) -> Self {
                    (value.challengeId,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for previewRewardCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { challengeId: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<previewRewardReturn> for UnderlyingRustTuple<'_> {
                fn from(value: previewRewardReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for previewRewardReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for previewRewardCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = previewRewardReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "previewReward(uint256)";
            const SELECTOR: [u8; 4] = [185u8, 115u8, 225u8, 191u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.challengeId),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    ///Container for all the [`HashChallenge`](self) function calls.
    pub enum HashChallengeCalls {
        #[allow(missing_docs)]
        calculateReward(calculateRewardCall),
        #[allow(missing_docs)]
        challenges(challengesCall),
        #[allow(missing_docs)]
        claimChallenge(claimChallengeCall),
        #[allow(missing_docs)]
        createChallenge(createChallengeCall),
        #[allow(missing_docs)]
        getChallenge(getChallengeCall),
        #[allow(missing_docs)]
        getRefund(getRefundCall),
        #[allow(missing_docs)]
        previewReward(previewRewardCall),
    }
    #[automatically_derived]
    impl HashChallengeCalls {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 4usize]] = &[
            [8u8, 229u8, 27u8, 81u8],
            [27u8, 221u8, 75u8, 116u8],
            [39u8, 54u8, 208u8, 181u8],
            [133u8, 250u8, 116u8, 188u8],
            [143u8, 29u8, 55u8, 118u8],
            [168u8, 230u8, 43u8, 151u8],
            [185u8, 115u8, 225u8, 191u8],
        ];
    }
    #[automatically_derived]
    impl alloy_sol_types::SolInterface for HashChallengeCalls {
        const NAME: &'static str = "HashChallengeCalls";
        const MIN_DATA_LENGTH: usize = 32usize;
        const COUNT: usize = 7usize;
        #[inline]
        fn selector(&self) -> [u8; 4] {
            match self {
                Self::calculateReward(_) => {
                    <calculateRewardCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::challenges(_) => {
                    <challengesCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::claimChallenge(_) => {
                    <claimChallengeCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::createChallenge(_) => {
                    <createChallengeCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getChallenge(_) => {
                    <getChallengeCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getRefund(_) => {
                    <getRefundCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::previewReward(_) => {
                    <previewRewardCall as alloy_sol_types::SolCall>::SELECTOR
                }
            }
        }
        #[inline]
        fn selector_at(i: usize) -> ::core::option::Option<[u8; 4]> {
            Self::SELECTORS.get(i).copied()
        }
        #[inline]
        fn valid_selector(selector: [u8; 4]) -> bool {
            Self::SELECTORS.binary_search(&selector).is_ok()
        }
        #[inline]
        #[allow(non_snake_case)]
        fn abi_decode_raw(
            selector: [u8; 4],
            data: &[u8],
            validate: bool,
        ) -> alloy_sol_types::Result<Self> {
            static DECODE_SHIMS: &[fn(
                &[u8],
                bool,
            ) -> alloy_sol_types::Result<HashChallengeCalls>] = &[
                {
                    fn createChallenge(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<HashChallengeCalls> {
                        <createChallengeCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(HashChallengeCalls::createChallenge)
                    }
                    createChallenge
                },
                {
                    fn getChallenge(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<HashChallengeCalls> {
                        <getChallengeCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(HashChallengeCalls::getChallenge)
                    }
                    getChallenge
                },
                {
                    fn claimChallenge(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<HashChallengeCalls> {
                        <claimChallengeCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(HashChallengeCalls::claimChallenge)
                    }
                    claimChallenge
                },
                {
                    fn getRefund(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<HashChallengeCalls> {
                        <getRefundCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(HashChallengeCalls::getRefund)
                    }
                    getRefund
                },
                {
                    fn challenges(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<HashChallengeCalls> {
                        <challengesCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(HashChallengeCalls::challenges)
                    }
                    challenges
                },
                {
                    fn calculateReward(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<HashChallengeCalls> {
                        <calculateRewardCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(HashChallengeCalls::calculateReward)
                    }
                    calculateReward
                },
                {
                    fn previewReward(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<HashChallengeCalls> {
                        <previewRewardCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(HashChallengeCalls::previewReward)
                    }
                    previewReward
                },
            ];
            let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                return Err(
                    alloy_sol_types::Error::unknown_selector(
                        <Self as alloy_sol_types::SolInterface>::NAME,
                        selector,
                    ),
                );
            };
            DECODE_SHIMS[idx](data, validate)
        }
        #[inline]
        fn abi_encoded_size(&self) -> usize {
            match self {
                Self::calculateReward(inner) => {
                    <calculateRewardCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::challenges(inner) => {
                    <challengesCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::claimChallenge(inner) => {
                    <claimChallengeCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::createChallenge(inner) => {
                    <createChallengeCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getChallenge(inner) => {
                    <getChallengeCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getRefund(inner) => {
                    <getRefundCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::previewReward(inner) => {
                    <previewRewardCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
            }
        }
        #[inline]
        fn abi_encode_raw(&self, out: &mut alloy_sol_types::private::Vec<u8>) {
            match self {
                Self::calculateReward(inner) => {
                    <calculateRewardCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::challenges(inner) => {
                    <challengesCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::claimChallenge(inner) => {
                    <claimChallengeCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::createChallenge(inner) => {
                    <createChallengeCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getChallenge(inner) => {
                    <getChallengeCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getRefund(inner) => {
                    <getRefundCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::previewReward(inner) => {
                    <previewRewardCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
            }
        }
    }
    ///Container for all the [`HashChallenge`](self) events.
    pub enum HashChallengeEvents {
        #[allow(missing_docs)]
        ChallengeClaimed(ChallengeClaimed),
        #[allow(missing_docs)]
        ChallengeCreated(ChallengeCreated),
        #[allow(missing_docs)]
        ChallengeRefunded(ChallengeRefunded),
    }
    #[automatically_derived]
    impl HashChallengeEvents {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 32usize]] = &[
            [
                21u8,
                155u8,
                123u8,
                189u8,
                198u8,
                6u8,
                243u8,
                122u8,
                64u8,
                193u8,
                56u8,
                200u8,
                240u8,
                83u8,
                121u8,
                152u8,
                137u8,
                207u8,
                117u8,
                36u8,
                218u8,
                32u8,
                249u8,
                163u8,
                21u8,
                22u8,
                245u8,
                101u8,
                101u8,
                158u8,
                52u8,
                155u8,
            ],
            [
                53u8,
                124u8,
                147u8,
                230u8,
                188u8,
                183u8,
                0u8,
                90u8,
                98u8,
                36u8,
                30u8,
                133u8,
                131u8,
                128u8,
                83u8,
                191u8,
                13u8,
                150u8,
                143u8,
                41u8,
                64u8,
                169u8,
                191u8,
                210u8,
                83u8,
                217u8,
                228u8,
                177u8,
                33u8,
                166u8,
                187u8,
                224u8,
            ],
            [
                210u8,
                247u8,
                147u8,
                26u8,
                128u8,
                32u8,
                133u8,
                179u8,
                208u8,
                35u8,
                77u8,
                76u8,
                50u8,
                12u8,
                231u8,
                238u8,
                0u8,
                65u8,
                218u8,
                150u8,
                103u8,
                140u8,
                226u8,
                191u8,
                92u8,
                147u8,
                232u8,
                211u8,
                215u8,
                230u8,
                95u8,
                82u8,
            ],
        ];
    }
    #[automatically_derived]
    impl alloy_sol_types::SolEventInterface for HashChallengeEvents {
        const NAME: &'static str = "HashChallengeEvents";
        const COUNT: usize = 3usize;
        fn decode_raw_log(
            topics: &[alloy_sol_types::Word],
            data: &[u8],
            validate: bool,
        ) -> alloy_sol_types::Result<Self> {
            match topics.first().copied() {
                Some(<ChallengeClaimed as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <ChallengeClaimed as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::ChallengeClaimed)
                }
                Some(<ChallengeCreated as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <ChallengeCreated as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::ChallengeCreated)
                }
                Some(
                    <ChallengeRefunded as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <ChallengeRefunded as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::ChallengeRefunded)
                }
                _ => {
                    alloy_sol_types::private::Err(alloy_sol_types::Error::InvalidLog {
                        name: <Self as alloy_sol_types::SolEventInterface>::NAME,
                        log: alloy_sol_types::private::Box::new(
                            alloy_sol_types::private::LogData::new_unchecked(
                                topics.to_vec(),
                                data.to_vec().into(),
                            ),
                        ),
                    })
                }
            }
        }
    }
    #[automatically_derived]
    impl alloy_sol_types::private::IntoLogData for HashChallengeEvents {
        fn to_log_data(&self) -> alloy_sol_types::private::LogData {
            match self {
                Self::ChallengeClaimed(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::ChallengeCreated(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::ChallengeRefunded(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
            }
        }
        fn into_log_data(self) -> alloy_sol_types::private::LogData {
            match self {
                Self::ChallengeClaimed(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::ChallengeCreated(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::ChallengeRefunded(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
            }
        }
    }
    use alloy::contract as alloy_contract;
    /**Creates a new wrapper around an on-chain [`HashChallenge`](self) contract instance.

See the [wrapper's documentation](`HashChallengeInstance`) for more details.*/
    #[inline]
    pub const fn new<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    >(
        address: alloy_sol_types::private::Address,
        provider: P,
    ) -> HashChallengeInstance<T, P, N> {
        HashChallengeInstance::<T, P, N>::new(address, provider)
    }
    /**Deploys this contract using the given `provider` and constructor arguments, if any.

Returns a new instance of the contract, if the deployment was successful.

For more fine-grained control over the deployment process, use [`deploy_builder`] instead.*/
    #[inline]
    pub fn deploy<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    >(
        provider: P,
    ) -> impl ::core::future::Future<
        Output = alloy_contract::Result<HashChallengeInstance<T, P, N>>,
    > {
        HashChallengeInstance::<T, P, N>::deploy(provider)
    }
    /**Creates a `RawCallBuilder` for deploying this contract using the given `provider`
and constructor arguments, if any.

This is a simple wrapper around creating a `RawCallBuilder` with the data set to
the bytecode concatenated with the constructor's ABI-encoded arguments.*/
    #[inline]
    pub fn deploy_builder<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    >(provider: P) -> alloy_contract::RawCallBuilder<T, P, N> {
        HashChallengeInstance::<T, P, N>::deploy_builder(provider)
    }
    /**A [`HashChallenge`](self) instance.

Contains type-safe methods for interacting with an on-chain instance of the
[`HashChallenge`](self) contract located at a given `address`, using a given
provider `P`.

If the contract bytecode is available (see the [`sol!`](alloy_sol_types::sol!)
documentation on how to provide it), the `deploy` and `deploy_builder` methods can
be used to deploy a new instance of the contract.

See the [module-level documentation](self) for all the available methods.*/
    #[derive(Clone)]
    pub struct HashChallengeInstance<T, P, N = alloy_contract::private::Ethereum> {
        address: alloy_sol_types::private::Address,
        provider: P,
        _network_transport: ::core::marker::PhantomData<(N, T)>,
    }
    #[automatically_derived]
    impl<T, P, N> ::core::fmt::Debug for HashChallengeInstance<T, P, N> {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            f.debug_tuple("HashChallengeInstance").field(&self.address).finish()
        }
    }
    /// Instantiation and getters/setters.
    #[automatically_derived]
    impl<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    > HashChallengeInstance<T, P, N> {
        /**Creates a new wrapper around an on-chain [`HashChallenge`](self) contract instance.

See the [wrapper's documentation](`HashChallengeInstance`) for more details.*/
        #[inline]
        pub const fn new(
            address: alloy_sol_types::private::Address,
            provider: P,
        ) -> Self {
            Self {
                address,
                provider,
                _network_transport: ::core::marker::PhantomData,
            }
        }
        /**Deploys this contract using the given `provider` and constructor arguments, if any.

Returns a new instance of the contract, if the deployment was successful.

For more fine-grained control over the deployment process, use [`deploy_builder`] instead.*/
        #[inline]
        pub async fn deploy(
            provider: P,
        ) -> alloy_contract::Result<HashChallengeInstance<T, P, N>> {
            let call_builder = Self::deploy_builder(provider);
            let contract_address = call_builder.deploy().await?;
            Ok(Self::new(contract_address, call_builder.provider))
        }
        /**Creates a `RawCallBuilder` for deploying this contract using the given `provider`
and constructor arguments, if any.

This is a simple wrapper around creating a `RawCallBuilder` with the data set to
the bytecode concatenated with the constructor's ABI-encoded arguments.*/
        #[inline]
        pub fn deploy_builder(provider: P) -> alloy_contract::RawCallBuilder<T, P, N> {
            alloy_contract::RawCallBuilder::new_raw_deploy(
                provider,
                ::core::clone::Clone::clone(&BYTECODE),
            )
        }
        /// Returns a reference to the address.
        #[inline]
        pub const fn address(&self) -> &alloy_sol_types::private::Address {
            &self.address
        }
        /// Sets the address.
        #[inline]
        pub fn set_address(&mut self, address: alloy_sol_types::private::Address) {
            self.address = address;
        }
        /// Sets the address and returns `self`.
        pub fn at(mut self, address: alloy_sol_types::private::Address) -> Self {
            self.set_address(address);
            self
        }
        /// Returns a reference to the provider.
        #[inline]
        pub const fn provider(&self) -> &P {
            &self.provider
        }
    }
    impl<T, P: ::core::clone::Clone, N> HashChallengeInstance<T, &P, N> {
        /// Clones the provider and returns a new instance with the cloned provider.
        #[inline]
        pub fn with_cloned_provider(self) -> HashChallengeInstance<T, P, N> {
            HashChallengeInstance {
                address: self.address,
                provider: ::core::clone::Clone::clone(&self.provider),
                _network_transport: ::core::marker::PhantomData,
            }
        }
    }
    /// Function calls.
    #[automatically_derived]
    impl<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    > HashChallengeInstance<T, P, N> {
        /// Creates a new call builder using this contract instance's provider and address.
        ///
        /// Note that the call can be any function call, not just those defined in this
        /// contract. Prefer using the other methods for building type-safe contract calls.
        pub fn call_builder<C: alloy_sol_types::SolCall>(
            &self,
            call: &C,
        ) -> alloy_contract::SolCallBuilder<T, &P, C, N> {
            alloy_contract::SolCallBuilder::new_sol(&self.provider, &self.address, call)
        }
        ///Creates a new call builder for the [`calculateReward`] function.
        pub fn calculateReward(
            &self,
            elapsedTime: alloy::sol_types::private::primitives::aliases::U256,
            maxTime: alloy::sol_types::private::primitives::aliases::U256,
            totalReward: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, calculateRewardCall, N> {
            self.call_builder(
                &calculateRewardCall {
                    elapsedTime,
                    maxTime,
                    totalReward,
                },
            )
        }
        ///Creates a new call builder for the [`challenges`] function.
        pub fn challenges(
            &self,
            _0: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, challengesCall, N> {
            self.call_builder(&challengesCall { _0 })
        }
        ///Creates a new call builder for the [`claimChallenge`] function.
        pub fn claimChallenge(
            &self,
            challengeId: alloy::sol_types::private::primitives::aliases::U256,
            preimage: alloy::sol_types::private::Bytes,
            claimedDelay: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, claimChallengeCall, N> {
            self.call_builder(
                &claimChallengeCall {
                    challengeId,
                    preimage,
                    claimedDelay,
                },
            )
        }
        ///Creates a new call builder for the [`createChallenge`] function.
        pub fn createChallenge(
            &self,
            dataHash: alloy::sol_types::private::FixedBytes<32>,
            responder: alloy::sol_types::private::Address,
            maxDelay: alloy::sol_types::private::primitives::aliases::U256,
            sequenceNumber: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, createChallengeCall, N> {
            self.call_builder(
                &createChallengeCall {
                    dataHash,
                    responder,
                    maxDelay,
                    sequenceNumber,
                },
            )
        }
        ///Creates a new call builder for the [`getChallenge`] function.
        pub fn getChallenge(
            &self,
            challengeId: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, getChallengeCall, N> {
            self.call_builder(&getChallengeCall { challengeId })
        }
        ///Creates a new call builder for the [`getRefund`] function.
        pub fn getRefund(
            &self,
            challengeId: alloy::sol_types::private::primitives::aliases::U256,
            refundAmount: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, getRefundCall, N> {
            self.call_builder(
                &getRefundCall {
                    challengeId,
                    refundAmount,
                },
            )
        }
        ///Creates a new call builder for the [`previewReward`] function.
        pub fn previewReward(
            &self,
            challengeId: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, previewRewardCall, N> {
            self.call_builder(&previewRewardCall { challengeId })
        }
    }
    /// Event filters.
    #[automatically_derived]
    impl<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    > HashChallengeInstance<T, P, N> {
        /// Creates a new event filter using this contract instance's provider and address.
        ///
        /// Note that the type can be any event, not just those defined in this contract.
        /// Prefer using the other methods for building type-safe event filters.
        pub fn event_filter<E: alloy_sol_types::SolEvent>(
            &self,
        ) -> alloy_contract::Event<T, &P, E, N> {
            alloy_contract::Event::new_sol(&self.provider, &self.address)
        }
        ///Creates a new event filter for the [`ChallengeClaimed`] event.
        pub fn ChallengeClaimed_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, ChallengeClaimed, N> {
            self.event_filter::<ChallengeClaimed>()
        }
        ///Creates a new event filter for the [`ChallengeCreated`] event.
        pub fn ChallengeCreated_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, ChallengeCreated, N> {
            self.event_filter::<ChallengeCreated>()
        }
        ///Creates a new event filter for the [`ChallengeRefunded`] event.
        pub fn ChallengeRefunded_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, ChallengeRefunded, N> {
            self.event_filter::<ChallengeRefunded>()
        }
    }
}
